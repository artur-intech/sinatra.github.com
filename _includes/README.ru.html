<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>

<p><a href="https://travis-ci.org/sinatra/sinatra"><img src="https://secure.travis-ci.org/sinatra/sinatra.svg" alt="Build Status"></a></p>

<p><em>Внимание: Этот документ является переводом английской версии и может быть
устаревшим</em></p>

<p>Sinatra — это предметно-ориентированный каркас
(<a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA">DSL</a>)
для быстрого создания функциональных веб-приложений на Ruby с минимумом усилий:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># myapp.rb</span>
<span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="s1">'Hello world!'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Установите gem:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>gem install sinatra
</code></pre>
</div>

<p>и запустите приложение при помощи:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>ruby myapp.rb
</code></pre>
</div>

<p>Оцените результат: <a href="http://localhost:4567">http://localhost:4567</a></p>

<p>Имейте ввиду, что изменения в коде не будут видны до тех пор, пока вы не перезапустите
сервер. Пожалуйста, перезагружайте сервер каждый раз как вносите изменения или добавьте
в проект <a href="http://www.sinatrarb.com/contrib/reloader">sinatra/reloader</a>.</p>

<p>Рекомендуется также установить Thin сервер  (<code class="highlighter-rouge">gem install thin</code>), который автоматически
работает с Sinatra приложениями.</p>

<h2>Содержание</h2>



<h2>Маршруты</h2>

<p>В Sinatra маршрут — это пара: &lt;HTTP метод&gt; и &lt;шаблон URL&gt;. Каждый маршрут
связан с блоком кода:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="c1"># .. что-то показать ..</span>
<span class="k">end</span>

<span class="n">post</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="c1"># .. что-то создать ..</span>
<span class="k">end</span>

<span class="n">put</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="c1"># .. что-то заменить ..</span>
<span class="k">end</span>

<span class="n">patch</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="c1"># .. что-то изменить ..</span>
<span class="k">end</span>

<span class="n">delete</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="c1"># .. что-то удалить ..</span>
<span class="k">end</span>

<span class="n">options</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="c1"># .. что-то ответить ..</span>
<span class="k">end</span>

<span class="n">link</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="c1"># .. что-то подключить ..</span>
<span class="k">end</span>

<span class="n">unlink</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="c1"># .. что-то отключить ..</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Маршруты сверяются с запросом в порядке очерёдности их записи в файле
приложения. Первый же совпавший с запросом маршрут и будет вызван.</p>

<p>Маршруты с конечным слэшем отличаются от маршрутов без него:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="c1"># не соответствует "GET /foo/"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Шаблоны маршрутов могут включать в себя именованные параметры, доступные в xэше
<code class="highlighter-rouge">params</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/hello/:name'</span> <span class="k">do</span>
  <span class="c1"># соответствует "GET /hello/foo" и "GET /hello/bar",</span>
  <span class="c1"># где params['name'] - это 'foo' или 'bar'</span>
  <span class="s2">"Hello </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Также можно получить доступ к именованным параметрам через параметры блока:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/hello/:name'</span> <span class="k">do</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span>
  <span class="c1"># соответствует "GET /hello/foo" и "GET /hello/bar",</span>
  <span class="c1"># где params['name'] - это 'foo' или 'bar'</span>
  <span class="c1"># n хранит params['name']</span>
  <span class="s2">"Hello </span><span class="si">#{</span><span class="n">n</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Шаблоны маршрутов также могут включать в себя splat параметры (или ‘*’ маску,
обозначающую любой символ), доступные в массиве <code class="highlighter-rouge">params['splat']</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/say/*/to/*'</span> <span class="k">do</span>
  <span class="c1"># соответствует /say/hello/to/world</span>
  <span class="n">params</span><span class="p">[</span><span class="s1">'splat'</span><span class="p">]</span> <span class="c1"># =&gt; ["hello", "world"]</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/download/*.*'</span> <span class="k">do</span>
  <span class="c1"># соответствует /download/path/to/file.xml</span>
  <span class="n">params</span><span class="p">[</span><span class="s1">'splat'</span><span class="p">]</span> <span class="c1"># =&gt; ["path/to/file", "xml"]</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Или с параметрами блока:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/download/*.*'</span> <span class="k">do</span> <span class="o">|</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="o">|</span>
  <span class="p">[</span><span class="n">path</span><span class="p">,</span> <span class="n">ext</span><span class="p">]</span> <span class="c1"># =&gt; ["path/to/file", "xml"]</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Можно также использовать регулярные выражения в качестве шаблонов маршрутов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="sr">/\/hello\/([\w]+)/</span> <span class="k">do</span>
  <span class="s2">"Hello, </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'captures'</span><span class="p">].</span><span class="nf">first</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Или с параметром блока:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># Соответствует "GET /meta/hello/world", "GET /hello/world/1234" и т.д.</span>
<span class="n">get</span> <span class="sr">%r{/hello/([</span><span class="se">\w</span><span class="sr">]+)}</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
  <span class="s2">"Hello, </span><span class="si">#{</span><span class="n">c</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Шаблоны маршрутов могут иметь необязательные параметры:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/posts/:format?'</span> <span class="k">do</span>
  <span class="c1"># соответствует "GET /posts/", "GET /posts/json", "GET /posts/xml" и т.д.</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Маршруты также могут использовать параметры запроса:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/posts'</span> <span class="k">do</span>
  <span class="c1"># соответствует "GET /posts?title=foo&amp;author=bar"</span>
  <span class="n">title</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'title'</span><span class="p">]</span>
  <span class="n">author</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'author'</span><span class="p">]</span>
  <span class="c1"># используются переменные title и author; запрос не обязателен для маршрута /posts</span>
<span class="k">end</span>
</code></pre>
</div>

<p><strong>Имеейте ввиду</strong>: если вы не отключите защиту от обратного пути в директориях
(<em>path traversal</em>, см. ниже), путь запроса может быть изменён до начала 
поиска подходящего маршрута.</p>

<p>Вы можете настроить Mustermann опции, используемые для данного маршрута, путём передачи в <code class="highlighter-rouge">:mustermann_opts</code> хэш:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'\A/posts\z'</span><span class="p">,</span> <span class="ss">:mustermann_opts</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:regexp</span><span class="p">,</span> <span class="ss">:check_anchors</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="p">}</span> <span class="k">do</span>
  <span class="c1"># в точности соответствует /posts, с явной привязкой</span>
  <span class="s2">"If you match an anchored pattern clap your hands!"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Это похоже на <a href="#%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F">условие</a>, но это не так! Эти опции будут объеденины в глобальный <code class="highlighter-rouge">:mustermann_opts</code> хэш, описанный
<a href="#%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D1%8B%D0%B5-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8">ниже</a>.</p>

<h3>Условия</h3>

<p>Маршруты могут включать в себя различные условия совпадений, такие как, например,
строка агента пользователя (user agent):</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span><span class="p">,</span> <span class="ss">:agent</span> <span class="o">=&gt;</span> <span class="sr">/Songbird (\d\.\d)[\d\/]*?/</span> <span class="k">do</span>
  <span class="s2">"You're using Songbird version </span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'agent'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="c1"># соответствует не-songbird браузерам</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Другими доступными условиями являются <code class="highlighter-rouge">host_name</code> и <code class="highlighter-rouge">provides</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span><span class="p">,</span> <span class="ss">:host_name</span> <span class="o">=&gt;</span> <span class="sr">/^admin\./</span> <span class="k">do</span>
  <span class="s2">"Admin Area, Access denied!"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span><span class="p">,</span> <span class="ss">:provides</span> <span class="o">=&gt;</span> <span class="s1">'html'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span><span class="p">,</span> <span class="ss">:provides</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'rss'</span><span class="p">,</span> <span class="s1">'atom'</span><span class="p">,</span> <span class="s1">'xml'</span><span class="p">]</span> <span class="k">do</span>
  <span class="n">builder</span> <span class="ss">:feed</span>
<span class="k">end</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">provides</code> ищет заголовок запроса <code class="highlighter-rouge">Accept</code>.</p>

<p>Вы можете с лёгкостью задавать собственные условия:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span><span class="p">(</span><span class="ss">:probability</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">value</span><span class="o">|</span> <span class="n">condition</span> <span class="p">{</span> <span class="nb">rand</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="p">}</span> <span class="p">}</span>

<span class="n">get</span> <span class="s1">'/win_a_car'</span><span class="p">,</span> <span class="ss">:probability</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="o">.</span><span class="mi">1</span> <span class="k">do</span>
  <span class="s2">"You won!"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/win_a_car'</span> <span class="k">do</span>
  <span class="s2">"Sorry, you lost."</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Ипользуйте splat-оператор (<code class="highlighter-rouge">*</code>) для условий, которые принимают несколько аргументов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span><span class="p">(</span><span class="ss">:auth</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">roles</span><span class="o">|</span>   <span class="c1"># &lt;- обратите внимание на звёздочку</span>
  <span class="n">condition</span> <span class="k">do</span>
    <span class="k">unless</span> <span class="n">logged_in?</span> <span class="o">&amp;&amp;</span> <span class="n">roles</span><span class="p">.</span><span class="nf">any?</span> <span class="p">{</span><span class="o">|</span><span class="n">role</span><span class="o">|</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">in_role?</span> <span class="n">role</span> <span class="p">}</span>
      <span class="n">redirect</span> <span class="s2">"/login/"</span><span class="p">,</span> <span class="mi">303</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s2">"/my/account/"</span><span class="p">,</span> <span class="ss">:auth</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:user</span><span class="p">,</span> <span class="ss">:admin</span><span class="p">]</span> <span class="k">do</span>
  <span class="s2">"Your Account Details"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s2">"/only/admin/"</span><span class="p">,</span> <span class="ss">:auth</span> <span class="o">=&gt;</span> <span class="ss">:admin</span> <span class="k">do</span>
  <span class="s2">"Only admins are allowed here!"</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Возвращаемые значения</h3>

<p>Возвращаемое значение блока маршрута ограничивается телом ответа, которое
будет передано HTTP клиенту, или, по крайней мере, следующей “прослойке” (middleware)
в Rack стеке. Чаще всего это строка как в примерах выше. Но также приемлемы и
другие значения.</p>

<p>Вы можете вернуть любой объект, который будет либо корректным Rack ответом,
либо объектом Rack body, либо кодом состояния HTTP:</p>

<ul>
  <li>массив с тремя переменными: <code class="highlighter-rouge">[код (Integer), заголовки (Hash), тело ответа
(должно отвечать на #each)]</code>;</li>
  <li>массив с двумя переменными: <code class="highlighter-rouge">[код (Integer), тело ответа (должно отвечать
на #each)]</code>;</li>
  <li>объект, отвечающий на <code class="highlighter-rouge">#each</code>, который передает только строковые типы
данных в этот блок;</li>
  <li>Integer, представляющий код состояния HTTP.</li>
</ul>

<p>Таким образом легко можно реализовать, например, потоковую передачу:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">Stream</span>
  <span class="k">def</span> <span class="nf">each</span>
    <span class="mi">100</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="k">yield</span> <span class="s2">"</span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="no">Stream</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>
</code></pre>
</div>

<p>Вы также можете использовать вспомогательный метод <code class="highlighter-rouge">stream</code> (описанный ниже)
для того, чтобы уменьшить количество шаблонного кода и встроить потоковую
логику прямо в маршрут.</p>

<h3>Собственные детекторы совпадений для маршрутов</h3>

<p>Как показано выше, Sinatra поставляется со встроенной поддержкой строк и
регулярных выражений в качестве шаблонов URL. Но и это ещё не всё. Вы можете
легко определить свои собственные детекторы совпадений (matchers) для
маршрутов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">AllButPattern</span>
  <span class="nc">Match</span> <span class="o">=</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:captures</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">except</span><span class="p">)</span>
    <span class="vi">@except</span>   <span class="o">=</span> <span class="n">except</span>
    <span class="vi">@captures</span> <span class="o">=</span> <span class="no">Match</span><span class="p">.</span><span class="nf">new</span><span class="p">([])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
    <span class="vi">@captures</span> <span class="k">unless</span> <span class="vi">@except</span> <span class="o">===</span> <span class="n">str</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">all_but</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
  <span class="no">AllButPattern</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">get</span> <span class="n">all_but</span><span class="p">(</span><span class="s2">"/index"</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Обратите внимание на то, что предыдущий пример, возможно, чересчур усложнён, потому что он
может быть реализован следующим образом:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="sr">//</span> <span class="k">do</span>
  <span class="n">pass</span> <span class="k">if</span> <span class="n">request</span><span class="p">.</span><span class="nf">path_info</span> <span class="o">==</span> <span class="s2">"/index"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Или с использованием негативной опережающей проверки (отрицательное look-ahead условие):</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="sr">%r{(?!/index)}</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>

<h2>Статические файлы</h2>

<p>Статические файлы раздаются из <code class="highlighter-rouge">./public</code> директории. Вы можете указать другое
месторасположение при помощи опции <code class="highlighter-rouge">:public_folder</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:public_folder</span><span class="p">,</span> <span class="n">__dir__</span> <span class="o">+</span> <span class="s1">'/static'</span>
</code></pre>
</div>

<p>Учтите, что имя директории со статическими файлами не включено в URL.
Например, файл <code class="highlighter-rouge">./public/css/style.css</code> будет доступен как
<code class="highlighter-rouge">http://example.com/css/style.css</code>.</p>

<p>Используйте опцию <code class="highlighter-rouge">:static_cache_control</code> (см. ниже) для того, чтобы добавить
заголовок <code class="highlighter-rouge">Cache-Control</code>.</p>

<h2>Представления / Шаблоны</h2>

<p>Каждый шаблонизатор представлен своим собственным методом. Эти методы попросту
возвращают строку:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Данный код отрендерит файл <code class="highlighter-rouge">views/index.erb</code>.</p>

<p>Вместо имени шаблона вы так же можете передавать непосредственно само
содержимое шаблона:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">code</span> <span class="o">=</span> <span class="s2">"&lt;%= Time.now %&gt;"</span>
  <span class="n">erb</span> <span class="n">code</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Метод рендеринга шаблона принимает в качестве второго аргумента хэш с опциями:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:index</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="ss">:post</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Данный метод отрендерит шаблон <code class="highlighter-rouge">views/index.erb</code>, который будет вложен в <code class="highlighter-rouge">views/post.erb</code>
(по умолчанию: <code class="highlighter-rouge">views/layout.erb</code>, если файл существует).</p>

<p>Любые опции, которые Sinatra не распознает, будут переданы в шаблонизатор:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span><span class="p">,</span> <span class="ss">:format</span> <span class="o">=&gt;</span> <span class="ss">:html5</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Вы также можете глобально задавать опции для шаблонизаторов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:haml</span><span class="p">,</span> <span class="ss">:format</span> <span class="o">=&gt;</span> <span class="ss">:html5</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Опции, переданные в метод, переопределяют опции, заданные при помощи <code class="highlighter-rouge">set</code>.</p>

<p>Доступные опции:</p>

<dl>
  <dt>locals</dt>
  <dd>
    Список локальных переменных, передаваемых в документ.
    Пример: <tt>erb "&lt;%= foo %&gt;", :locals =&gt; {:foo =&gt; "bar"}</tt>
  </dd>

  <dt>default_encoding</dt>
  <dd>
    Кодировка, которую следует использовать в том случае, если не удалось
    определить оригинальную. По умолчанию: <tt>settings.default_encoding</tt>.
  </dd>

  <dt>views</dt>
  <dd>
    Директория с шаблонами. По умолчанию: <tt>settings.views</tt>.
  </dd>

  <dt>layout</dt>
  <dd>
    Определяет необходимость использования лэйаута (<tt>true</tt> или <tt>false</tt>).
    Если же в качестве значения передан символ, то его значение будет интерпретировано
    как наименования файла шаблона лэйаута.
    Пример: <tt>erb :index, :layout =&gt; !request.xhr?</tt>
  </dd>

  <dt>content_type</dt>
  <dd>
    Content-Type отображенного шаблона. По умолчанию: задаётся шаблонизатором.
  </dd>

  <dt>scope</dt>
  <dd>
    Область видимости, в которой рендерятся шаблоны. По умолчанию: экземпляр
    приложения. Если вы измените эту опцию, то переменные экземпляра и
    методы-помощники станут недоступными в ваших шаблонах.
  </dd>

  <dt>layout_engine</dt>
  <dd>
    Шаблонизатор, который следует использовать для отображения лэйаута.
    Полезная опция для шаблонизаторов, в которых отсутствует поддержка
    лэйаутов. По умолчанию: тот же шаблонизатор, что используется и для самого
    шаблона. Пример: <tt>set :rdoc, :layout_engine =&gt; :erb</tt>
  </dd>

  <dt>layout_options</dt>
  <dd>
    Специальные опции, используемые только для рендеринга лэйаута. Пример:
    <tt>set :rdoc, :layout_options =&gt; { :views =&gt; 'views/layouts' }</tt>
  </dd>
</dl>

<p>По умолчанию в качестве пути для хранения шаблонов принята директория <code class="highlighter-rouge">./views</code>.
Чтобы назначить другую директорию с шаблонами необходимо изменить настройки:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:views</span><span class="p">,</span> <span class="n">settings</span><span class="p">.</span><span class="nf">root</span> <span class="o">+</span> <span class="s1">'/templates'</span>
</code></pre>
</div>

<p>Важное замечание: вы всегда должны ссылаться на шаблоны при помощи символов
(Symbol), даже тогда, когда они расположены в поддиректории (в этом случае
используйте конструкции вида <code class="highlighter-rouge">:'subdir/template'</code>). Вы должны использовать
символы в связи с тем, что в ином случае шаблонизаторы попросту отображают
любые строки, переданные им.</p>

<h3>Буквальные шаблоны</h3>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="s1">'%div.title Hello World'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Отобразит шаблон, содержимое которого передано строкой. Опционально можно
указать дополнительные опции <code class="highlighter-rouge">:path</code> и <code class="highlighter-rouge">:line</code> для того, чтобы улучшить бэктрейс.
Делайте это в том случае, если строка определена в некотором файле, к которому
можно указать путь и номер строки, где расположена исходная строка:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="s1">'%div.title Hello World'</span><span class="p">,</span> <span class="ss">:path</span> <span class="o">=&gt;</span> <span class="s1">'examples/file.haml'</span><span class="p">,</span> <span class="ss">:line</span> <span class="o">=&gt;</span> <span class="mi">3</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Доступные шаблонизаторы</h3>

<p>Некоторые языки шаблонов имеют несколько реализаций. Для того, чтобы указать
конкретную реализацию, которую вы хотите использовать, вам следует просто
подключить нужную библиотеку:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rdiscount'</span> <span class="c1"># или require 'bluecloth'</span>
<span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="n">markdown</span> <span class="ss">:index</span> <span class="p">}</span>
</code></pre>
</div>

<h4>Haml шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://haml.info/" title="haml">haml</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.haml</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>haml :index, :format =&gt; :html5</tt></td>
  </tr>
</table>

<h4>Erb шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      <a href="http://www.kuwata-lab.com/erubis/" title="erubis">erubis</a>
      или erb (включён в Ruby)
    </td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td>
<tt>.erb</tt>, <tt>.rhtml</tt> or <tt>.erubis</tt> (только Erubis)</td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>erb :index</tt></td>
  </tr>
</table>

<h4>Builder шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      <a href="https://github.com/jimweirich/builder" title="builder">builder</a>
    </td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.builder</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>builder { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

<p>Шаблонизатор также принимает блоки для включённых шаблонов (<a href="#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B">см. пример</a>).</p>

<h4>Nokogiri шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://www.nokogiri.org/" title="nokogiri">nokogiri</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.nokogiri</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>nokogiri { |xml| xml.em "hi" }</tt></td>
  </tr>
</table>

<p>Шаблонизатор также принимает блоки для включённых шаблонов (<a href="#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B">см. пример</a>).</p>

<h4>Sass шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.sass</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>sass :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>

<h4>SCSS шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://sass-lang.com/" title="sass">sass</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.scss</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>scss :stylesheet, :style =&gt; :expanded</tt></td>
  </tr>
</table>

<h4>Less шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://lesscss.org/" title="less">less</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.less</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>less :stylesheet</tt></td>
  </tr>
</table>

<h4>Liquid шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://shopify.github.io/liquid/" title="liquid">liquid</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.liquid</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>liquid :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>В связи с тем, что в Liquid шаблонах невозможно вызывать методы из Ruby
(за исключением <code class="highlighter-rouge">yield</code>), вам почти всегда понадобиться передавать в шаблон
локальные переменные.</p>

<h4>Markdown шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      Любая из библиотек:
        <a href="https://github.com/davidfstr/rdiscount" title="RDiscount">RDiscount</a>,
        <a href="https://github.com/vmg/redcarpet" title="RedCarpet">RedCarpet</a>,
        <a href="https://github.com/ged/bluecloth" title="bluecloth">BlueCloth</a>,
        <a href="https://kramdown.gettalong.org/" title="kramdown">kramdown</a>,
        <a href="https://github.com/bhollis/maruku" title="maruku">maruku</a>
    </td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td>
<tt>.markdown</tt>, <tt>.mkd</tt> and <tt>.md</tt>
</td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>markdown :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>В Markdown невозможно вызывать методы или передавать локальные переменные.
По этой причине вам, скорее всего, придётся использовать этот шаблон совместно
с другим шаблонизатором:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">markdown</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<p>Обратите внимание на то, что вы можете вызывать метод <code class="highlighter-rouge">markdown</code> из других шаблонов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">markdown</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre>
</div>

<p>Вы не можете вызывать Ruby код код из Markdown, соответственно вы не можете
использовать лэйауты на Markdown. Тем не менее, существует возможность использовать
один шаблонизатор для отображения шаблона, а другой для лэйаута при помощи
опции <code class="highlighter-rouge">:layout_engine</code>.</p>

<h4>Textile шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://redcloth.org/" title="RedCloth">RedCloth</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.textile</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>textile :index, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>В Textile невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придётся использовать данный шаблон
совместно с другим шаблонизатором:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">textile</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<p>Обратите внимание на то, что вы можете вызывать метод <code class="highlighter-rouge">textile</code> из других шаблонов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">textile</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre>
</div>

<p>Вы не можете вызывать Ruby код код из Textile, соответственно вы не можете
использовать лэйауты на Textile. Тем не менее, существует возможность использовать
один шаблонизатор для отображения шаблона, а другой для лэйаута при помощи
опции <code class="highlighter-rouge">:layout_engine</code>.</p>

<h4>RDoc шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://rdoc.sourceforge.net/" title="RDoc">RDoc</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.rdoc</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>rdoc :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>В RDoc невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придётся использовать этот шаблон совместно
с другим шаблонизатором:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">rdoc</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<p>Обратите внимание на то, что вы можете вызывать метод <code class="highlighter-rouge">rdoc</code> из других шаблонов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">rdoc</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre>
</div>

<p>Вы не можете вызывать Ruby код код из RDoc, соответственно вы не можете использовать
лэйауты на RDoc. Тем не менее, существует возможность использовать один шаблонизатор
для отображения шаблона, а другой для лэйаута при помощи опции
<code class="highlighter-rouge">:layout_engine</code>.</p>

<h4>AsciiDoc шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://asciidoctor.org/" title="Asciidoctor">Asciidoctor</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td>
<tt>.asciidoc</tt>, <tt>.adoc</tt> и <tt>.ad</tt>
</td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>asciidoc :README, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>Так как в AsciiDoc шаблонах невозможно вызывать методы из Ruby напрямую, то вы
почти всегда будете передавать в шаблон локальные переменные.</p>

<h4>Radius шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/jlong/radius" title="Radius">Radius</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.radius</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>radius :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>Так как в Radius шаблонах невозможно вызывать методы из Ruby напрямую, то вы
почти всегда будете передавать в шаблон локальные переменные.</p>

<h4>Markaby шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://markaby.github.io/" title="Markaby">Markaby</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.mab</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>markaby { h1 "Welcome!" }</tt></td>
  </tr>
</table>

<p>Шаблонизатор также принимает блоки для включённых шаблонов (<a href="#%D0%92%D0%BA%D0%BB%D1%8E%D1%87%D1%91%D0%BD%D0%BD%D1%8B%D0%B5-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B">см. пример</a>).</p>

<h4>RABL шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/nesquena/rabl" title="Rabl">Rabl</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.rabl</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>rabl :index</tt></td>
  </tr>
</table>

<h4>Slim шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="http://slim-lang.com/" title="Slim Lang">Slim Lang</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.slim</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>slim :index</tt></td>
  </tr>
</table>

<h4>Creole шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/minad/creole" title="Creole">Creole</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.creole</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>creole :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>В Creole невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придётся использовать данный шаблон совместно
с другим шаблонизатором:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">creole</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<p>обратите внимание на то, что вы можете вызывать метод <code class="highlighter-rouge">creole</code> из других шаблонов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">creole</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre>
</div>

<p>Вы не можете вызывать Ruby код из Creole, соответственно вы не можете
использовать лэйауты на Creole. Тем не менее, существует возможность использовать
один шаблонизатор для отображения шаблона, а другой для лэйаута при помощи
опции <code class="highlighter-rouge">:layout_engine</code>.</p>

<h4>MediaWiki шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/nricciar/wikicloth" title="WikiCloth">WikiCloth</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td>
<tt>.mediawiki</tt> и <tt>.mw</tt>
</td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>mediawiki :wiki, :layout_engine =&gt; :erb</tt></td>
  </tr>
</table>

<p>В разметке MediaWiki невозможно вызывать методы или передавать локальные переменные.
Следовательно, вам, скорее всего, придётся использовать этот шаблон совместно
с другим шаблонизатором:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">erb</span> <span class="ss">:overview</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="n">mediawiki</span><span class="p">(</span><span class="ss">:introduction</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<p>Обратите внимание на то, что вы можете вызывать метод <code class="highlighter-rouge">mediawiki</code> из других шаблонов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="o">%</span><span class="n">h1</span> <span class="no">Hello</span> <span class="no">From</span> <span class="no">Haml</span><span class="o">!</span>
<span class="o">%</span><span class="nb">p</span><span class="o">=</span> <span class="n">mediawiki</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
</code></pre>
</div>

<p>Вы не можете вызывать Ruby код из MediaWiki, соответственно вы не можете
использовать лэйауты на MediaWiki. Тем не менее, существует возможность использовать
один шаблонизатор для отображения шаблона, а другой для лэйаута при помощи
опции <code class="highlighter-rouge">:layout_engine</code>.</p>

<h4>CoffeeScript шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      <a href="https://github.com/josh/ruby-coffee-script" title="Ruby CoffeeScript">
        CoffeeScript
      </a> и
      <a href="https://github.com/sstephenson/execjs" title="ExecJS">
        способ запускать JavaScript
      </a>
    </td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.coffee</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>coffee :index</tt></td>
  </tr>
</table>

<h4>Stylus шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td>
      <a href="https://github.com/forgecrafted/ruby-stylus" title="Ruby Stylus">
        Stylus
      </a> и
      <a href="https://github.com/sstephenson/execjs" title="ExecJS">
        способ запускать JavaScript
      </a>
    </td>
  </tr>
  <tr>
    <td>Расширение файла</td>
    <td><tt>.styl</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>stylus :index</tt></td>
  </tr>
</table>

<p>Перед тем, как использовать шаблоны Stylus, необходимо сперва подключить
<code class="highlighter-rouge">stylus</code> и <code class="highlighter-rouge">stylus/tilt</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>
<span class="nb">require</span> <span class="s1">'stylus'</span>
<span class="nb">require</span> <span class="s1">'stylus/tilt'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">stylus</span> <span class="ss">:example</span>
<span class="k">end</span>
</code></pre>
</div>

<h4>Yajl шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/brianmario/yajl-ruby" title="yajl-ruby">yajl-ruby</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.yajl</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td>
      <tt>
        yajl :index,
             :locals =&gt; { :key =&gt; 'qux' },
             :callback =&gt; 'present',
             :variable =&gt; 'resource'
      </tt>
    </td>
  </tr>
</table>

<p>Содержимое шаблона интерпретируется как код на Ruby, а результирующая
переменная json затем конвертируется при помощи <code class="highlighter-rouge">#to_json</code>.</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">json</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">:foo</span> <span class="o">=&gt;</span> <span class="s1">'bar'</span> <span class="p">}</span>
<span class="n">json</span><span class="p">[</span><span class="ss">:baz</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
</code></pre>
</div>

<p>Опции <code class="highlighter-rouge">:callback</code> и <code class="highlighter-rouge">:variable</code> используются для “декорирования” итогового
объекта:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">var</span> <span class="n">resource</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"foo"</span><span class="ss">:"bar"</span><span class="p">,</span><span class="s2">"baz"</span><span class="ss">:"qux"</span><span class="p">};</span>
<span class="n">present</span><span class="p">(</span><span class="n">resource</span><span class="p">);</span>
</code></pre>
</div>

<h4>WLang шаблоны</h4>

<table>
  <tr>
    <td>Зависимости</td>
    <td><a href="https://github.com/blambeau/wlang" title="WLang">WLang</a></td>
  </tr>
  <tr>
    <td>Расширения файлов</td>
    <td><tt>.wlang</tt></td>
  </tr>
  <tr>
    <td>Пример</td>
    <td><tt>wlang :index, :locals =&gt; { :key =&gt; 'value' }</tt></td>
  </tr>
</table>

<p>Так как в WLang шаблонах невозможно вызывать методы из Ruby напрямую (за
исключением <code class="highlighter-rouge">yield</code>), то вы почти всегда будете передавать в шаблон локальные
переменные. Лэйауты также могут быть описаны при помощи WLang.</p>

<h3>Доступ к переменным в шаблонах</h3>

<p>Шаблоны интерпретируются в том же контексте, что и обработчики маршрутов.
Переменные экземпляра, установленные в процессе обработки маршрутов, будут
доступны напрямую в шаблонах:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/:id'</span> <span class="k">do</span>
  <span class="vi">@foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">'id'</span><span class="p">])</span>
  <span class="n">haml</span> <span class="s1">'%h1= @foo.name'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Вы также можете установить их при помощи хэша локальных переменных:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/:id'</span> <span class="k">do</span>
  <span class="n">foo</span> <span class="o">=</span> <span class="no">Foo</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">'id'</span><span class="p">])</span>
  <span class="n">haml</span> <span class="s1">'%h1= bar.name'</span><span class="p">,</span> <span class="ss">:locals</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">:bar</span> <span class="o">=&gt;</span> <span class="n">foo</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Это обычный подход, применяемый тогда, когда шаблоны рендерятся как части других шаблонов.</p>

<h3>Шаблоны с <code class="highlighter-rouge">yield</code> и вложенные лэйауты</h3>

<p>Лэйаут (layout) обычно представляет собой шаблон, который исполняет
<code class="highlighter-rouge">yield</code>. Такой шаблон может быть использован либо при помощи опции <code class="highlighter-rouge">:template</code>,
как описано выше, либо при помощи блока:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">erb</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Эти инструкции по сути эквивалентны <code class="highlighter-rouge">erb :index, :layout =&gt; :post</code>.</p>

<p>Передача блоков интерпретирующим шаблоны методам наиболее полезна для
создания вложенных лэйаутов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">erb</span> <span class="ss">:main_layout</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="kp">false</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:admin_layout</span> <span class="k">do</span>
    <span class="n">erb</span> <span class="ss">:user</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>То же самое может быть сделано в более короткой форме:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">erb</span> <span class="ss">:admin_layout</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="ss">:main_layout</span> <span class="k">do</span>
  <span class="n">erb</span> <span class="ss">:user</span>
<span class="k">end</span>
</code></pre>
</div>

<p>В настоящее время следующие методы шаблонизаторов
принимают блок: <code class="highlighter-rouge">erb</code>, <code class="highlighter-rouge">haml</code>, <code class="highlighter-rouge">liquid</code>, <code class="highlighter-rouge">slim </code>, <code class="highlighter-rouge">wlang</code>. Кроме того,
общий метод построения шаблонов <code class="highlighter-rouge">render</code> также принимает блок.</p>

<h3>Включённые шаблоны</h3>

<p>Шаблоны также могут быть определены в конце исходного файла:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span>
<span class="k">end</span>

<span class="cp">__END__

@@ layout
%html
  = yield

@@ index
%div.title Hello world.
</span></code></pre>
</div>

<p>Обратите внимание: включённые шаблоны, определённые в исходном файле, который подключил
Sinatra, будут загружены автоматически. Вызовите <code class="highlighter-rouge">enable :inline_templates</code>
напрямую в том случае, если используете включённые шаблоны в других файлах.</p>

<h3>Именованные шаблоны</h3>

<p>Шаблоны также могут быть определены при помощи метода <code class="highlighter-rouge">template</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">template</span> <span class="ss">:layout</span> <span class="k">do</span>
  <span class="s2">"%html</span><span class="se">\n</span><span class="s2">  =yield</span><span class="se">\n</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">template</span> <span class="ss">:index</span> <span class="k">do</span>
  <span class="s1">'%div.title Hello World!'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Если шаблон с именем “layout” существует, то он будет использоваться каждый
раз при рендеринге. Вы можете отключать лэйаут в каждом конкретном случае при
помощи опции <code class="highlighter-rouge">:layout =&gt; false</code> или отключить его для всего приложения: <code class="highlighter-rouge">set :haml,
:layout =&gt; false</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">haml</span> <span class="ss">:index</span><span class="p">,</span> <span class="ss">:layout</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="n">request</span><span class="p">.</span><span class="nf">xhr?</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Привязка файловых расширений</h3>

<p>Для того, чтобы связать расширение файла с движком рендеринга, используйте
<code class="highlighter-rouge">Tilt.register</code>. Так, например, вызовите следующий код в том случае, если вы
хотите использовать расширение <code class="highlighter-rouge">tt</code> для шаблонов Textile:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="no">Tilt</span><span class="p">.</span><span class="nf">register</span> <span class="ss">:tt</span><span class="p">,</span> <span class="no">Tilt</span><span class="p">[</span><span class="ss">:textile</span><span class="p">]</span>
</code></pre>
</div>

<h3>Добавление собственного движка рендеринга</h3>

<p>Сначала зарегистрируйте собственный движок в Tilt, а затем создайте метод, отвечающий
за рендеринг:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="no">Tilt</span><span class="p">.</span><span class="nf">register</span> <span class="ss">:myat</span><span class="p">,</span> <span class="no">MyAwesomeTemplateEngine</span>

<span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">myat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="n">render</span><span class="p">(</span><span class="ss">:myat</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">myat</span> <span class="ss">:index</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Данный код отрендерит <code class="highlighter-rouge">./views/index.myat</code>.
Подробнее о <a href="https://github.com/rtomayko/tilt#readme">Tilt</a>.</p>

<h3>Использование пользовательской логики для поиска шаблона</h3>

<p>Для того, чтобы реализовать собственный механизм поиска шаблона, 
необходимо написать метод <code class="highlighter-rouge">#find_template</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">configure</span> <span class="k">do</span>
  <span class="n">set</span> <span class="ss">:views</span> <span class="p">[</span> <span class="s1">'./views/a'</span><span class="p">,</span> <span class="s1">'./views/b'</span> <span class="p">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">find_template</span><span class="p">(</span><span class="n">views</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Array</span><span class="p">(</span><span class="n">views</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span>
    <span class="k">super</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h2>Фильтры</h2>

<p><code class="highlighter-rouge">before</code>-фильтры выполняются перед каждым запросом в том же контексте, что и
маршруты, и могут изменять как запрос, так и ответ на него. Переменные
экземпляра, установленные в фильтрах, доступны в маршрутах и шаблонах:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">before</span> <span class="k">do</span>
  <span class="vi">@note</span> <span class="o">=</span> <span class="s1">'Hi!'</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">path_info</span> <span class="o">=</span> <span class="s1">'/foo/bar/baz'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/foo/*'</span> <span class="k">do</span>
  <span class="vi">@note</span> <span class="c1">#=&gt; 'Hi!'</span>
  <span class="n">params</span><span class="p">[</span><span class="s1">'splat'</span><span class="p">]</span> <span class="c1">#=&gt; 'bar/baz'</span>
<span class="k">end</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">after</code>-фильтры выполняются после каждого запроса в том же контексте
и могут изменять как запрос, так и ответ на него. Переменные
экземпляра, установленные в <code class="highlighter-rouge">before</code>-фильтрах и маршрутах, будут доступны в
<code class="highlighter-rouge">after</code>-фильтрах:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">after</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="n">response</span><span class="p">.</span><span class="nf">status</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Обратите внимание: если вы используете метод <code class="highlighter-rouge">body</code>, а не просто возвращаете строку из
маршрута, то тело ответа не будет доступно в <code class="highlighter-rouge">after</code>-фильтрах, так как оно
будет сгенерировано позднее.</p>

<p>Фильтры также могут использовать шаблоны URL и будут выполнены только в том случае,
если путь запроса совпадет с указанным шаблоном:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">before</span> <span class="s1">'/protected/*'</span> <span class="k">do</span>
  <span class="n">authenticate!</span>
<span class="k">end</span>

<span class="n">after</span> <span class="s1">'/create/:slug'</span> <span class="k">do</span> <span class="o">|</span><span class="n">slug</span><span class="o">|</span>
  <span class="n">session</span><span class="p">[</span><span class="ss">:last_slug</span><span class="p">]</span> <span class="o">=</span> <span class="n">slug</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Как и маршруты, фильтры могут использовать условия:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">before</span> <span class="ss">:agent</span> <span class="o">=&gt;</span> <span class="sr">/Songbird/</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="n">after</span> <span class="s1">'/blog/*'</span><span class="p">,</span> <span class="ss">:host_name</span> <span class="o">=&gt;</span> <span class="s1">'example.com'</span> <span class="k">do</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>

<h2>Методы-помощники</h2>

<p>Используйте высокоуровневый метод <code class="highlighter-rouge">helpers</code> для того, чтобы определить 
методы-помощники, которые могут быть использованы в обработчиках маршрутов
и шаблонах:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">bar"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/:name'</span> <span class="k">do</span>
  <span class="n">bar</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">])</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Также методы-помощники могут быть заданы в отдельных модулях:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="k">module</span> <span class="nn">FooUtils</span>
  <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">foo"</span> <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">BarUtils</span>
  <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">bar"</span> <span class="k">end</span>
<span class="k">end</span>

<span class="n">helpers</span> <span class="no">FooUtils</span><span class="p">,</span> <span class="no">BarUtils</span>
</code></pre>
</div>

<p>Эффект равносилен включению модулей в класс приложения.</p>

<h3>Использование сессий</h3>

<p>Сессия используется для того, чтобы сохранять состояние между запросами. Если
эта опция включена, то у вас будет один хэш сессии на один пользовательский сеанс:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">enable</span> <span class="ss">:sessions</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="s2">"value = "</span> <span class="o">&lt;&lt;</span> <span class="n">session</span><span class="p">[</span><span class="ss">:value</span><span class="p">].</span><span class="nf">inspect</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/:value'</span> <span class="k">do</span>
  <span class="n">session</span><span class="p">[</span><span class="s1">'value'</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'value'</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Безопасность сессии</h3>

<p>Для того, чтобы повысить безопасность, данные сессии в файле ‘cookie’
подписываются ключом сессии с использованием <code class="highlighter-rouge">HMAC-SHA1</code>. Этот ключ сессии
должен быть оптимальным криптографическим ‘secure random’ значением соответствующей 
длины, которая для <code class="highlighter-rouge">HMAC-SHA1</code> больше или равна 64 байтам (512 бит, 128 
шестнадцатеричных символов). Не рекомендуется использовать ключ, длина
которого менее 32 байт (256 бит, 64 шестнадцатеричных символа). Поэтому 
<strong>очень важно</strong>, чтобы вы не просто составили значение ключа, а использовали 
безопасный генератор случайных чисел для его создания. Люди очень плохо
придумывают случайные значения.</p>

<p>По умолчанию, Sinatra создаёт для вас безопасный случайный ключ сессии из
32 байт, однако он будет меняться при каждом перезапуске приложения. Если у
вас есть несколько экземпляров вашего приложения, и вы доверили Sinatra 
генерацию ключа, то каждый экземпляр будет иметь отличный ключ сессии, 
что, вероятно, не совсем то, что вам необходимо.</p>

<p>Для лучшей безопасности и удобства использования
<a href="https://12factor.net/config">рекомендуется</a> генерировать случайный безопасный 
ключ и хранить его в переменной среды на каждом хосте, на котором запущено 
приложение, чтобы все экземпляры вашего приложения использовали один и тот 
же ключ. Вы должны периодически менять значение ключа сессии на новое. 
Вот несколько примеров того, как вы можете создать 64-байтный ключ
и установить его:</p>

<p><strong>Генерация ключа сессии</strong></p>

<div class="language-text highlighter-rouge">
<pre class="highlight"><code>$ ruby -e "require 'securerandom'; puts SecureRandom.hex(64)"
99ae8af...snip...ec0f262ac
</code></pre>
</div>

<p><strong>Генерация ключа сессии (бонусные пункты)</strong></p>

<p>Используйте <a href="https://github.com/cryptosphere/sysrandom#readme">гем ‘sysrandom’</a>.
Предпочтительнее использовать системные средства RNG для генерации случайных 
значений вместо пространства пользователя <code class="highlighter-rouge">OpenSSL</code>, который в настоящее время
по умолчанию используется в MRI Ruby:</p>

<div class="language-text highlighter-rouge">
<pre class="highlight"><code>$ gem install sysrandom
Создание собственных расширений. Это может занять некоторое время... 
Успешно установлен sysrandom-1.x
1 gem установлен

$ ruby -e "require 'sysrandom/securerandom'; puts SecureRandom.hex(64)"
99ae8af...snip...ec0f262ac
</code></pre>
</div>

<p><strong>Переменная среды для ключа сессии</strong></p>

<p>Задайте переменной среды <code class="highlighter-rouge">SESSION_SECRET</code> значение, которое вы 
сгенерировали. Данная переменная автоматически будет использована Sinatra.
Сделайте это значение постоянным при перезагрузке вашего 
сервера. Поскольку метод для генерации будет различным в разных системах, 
то код ниже приведён только в качестве примера:</p>

<div class="language-bash highlighter-rouge">
<pre class="highlight"><code><span class="c"># echo "export SESSION_SECRET=99ae8af...snip...ec0f262ac" &gt;&gt; ~/.bashrc</span>
</code></pre>
</div>

<p><strong>Конфигурация приложения</strong></p>

<p>В целях безопасности настройте конфигурацию вашего приложения таким образом,
чтобы оно генерировало случайный безопасный ключ тогда, когда переменная
среды <code class="highlighter-rouge">SESSION_SECRET</code> не доступна.</p>

<p>В качестве бонусных пунктов здесь тоже используйте 
<a href="https://github.com/cryptosphere/sysrandom">гем ‘sysrandom’gem</a>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'securerandom'</span>
<span class="c1"># -или- require 'sysrandom/securerandom'</span>
<span class="n">set</span> <span class="ss">:session_secret</span><span class="p">,</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">fetch</span><span class="p">(</span><span class="s1">'SESSION_SECRET'</span><span class="p">)</span> <span class="p">{</span> <span class="no">SecureRandom</span><span class="p">.</span><span class="nf">hex</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="p">}</span>
</code></pre>
</div>

<h4>Конфигурация сессии</h4>

<p>Если вы хотите больше настроек для сессий, вы можете задать их, передав хэш
опций в параметр <code class="highlighter-rouge">sessions</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:sessions</span><span class="p">,</span> <span class="ss">:domain</span> <span class="o">=&gt;</span> <span class="s1">'foo.com'</span>
</code></pre>
</div>

<p>Чтобы сделать сессию доступной другим приложениям, размещенным на поддоменах
foo.com, добавьте <em>.</em> перед доменом:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:sessions</span><span class="p">,</span> <span class="ss">:domain</span> <span class="o">=&gt;</span> <span class="s1">'.foo.com'</span>
</code></pre>
</div>

<h4>Выбор вашей собственной “прослойки” сессии</h4>

<p>Обратите внимание на то, что при использовании <code class="highlighter-rouge">enable :sessions</code> все данные
сохраняются в куках (cookies). Это может быть не совсем то, что вы хотите (например,
сохранение больших объёмов данных увеличит ваш трафик). В таком случае вы
можете использовать альтернативную Rack “прослойку” (middleware), реализующую
механизм сессий. Для этого используете один из способов ниже:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">enable</span> <span class="ss">:sessions</span>
<span class="n">set</span> <span class="ss">:session_store</span><span class="p">,</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Session</span><span class="o">::</span><span class="no">Pool</span>
</code></pre>
</div>

<p>Или установите параметры сессии при помощи хэша опций:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:sessions</span><span class="p">,</span> <span class="ss">:expire_after</span> <span class="o">=&gt;</span> <span class="mi">2592000</span>
<span class="n">set</span> <span class="ss">:session_store</span><span class="p">,</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Session</span><span class="o">::</span><span class="no">Pool</span>
</code></pre>
</div>

<p>Вы также можете <strong>не вызывать</strong> <code class="highlighter-rouge">enable :sessions</code>, а вместо этого использовать
необходимую вам Rack прослойку так же, как вы это обычно делаете.</p>

<p>Очень важно обратить внимание на то, что когда вы используете этот метод, 
основной способ защиты сессии <strong>не будет включён по умолчанию</strong>.</p>

<p>Вам также потребуется добавить следующие Rack middleware для этого:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Session</span><span class="o">::</span><span class="no">Pool</span><span class="p">,</span> <span class="ss">:expire_after</span> <span class="o">=&gt;</span> <span class="mi">2592000</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Protection</span><span class="o">::</span><span class="no">RemoteToken</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Protection</span><span class="o">::</span><span class="no">SessionHijacking</span>
</code></pre>
</div>

<p>Смотрите раздел <a href="#%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D1%8B-%D0%BE%D1%82-%D0%B0%D1%82%D0%B0%D0%BA">“Настройка защиты от атак”</a> для более подробной информации.</p>

<h3>Прерывание</h3>

<p>Чтобы незамедлительно прервать обработку запроса внутри фильтра или маршрута,
используйте следующую команду:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">halt</span>
</code></pre>
</div>

<p>Можно также указать статус при прерывании:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">halt</span> <span class="mi">410</span>
</code></pre>
</div>

<p>Тело:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">halt</span> <span class="s1">'this will be the body'</span>
</code></pre>
</div>

<p>И то, и другое:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">halt</span> <span class="mi">401</span><span class="p">,</span> <span class="s1">'go away!'</span>
</code></pre>
</div>

<p>Можно указать заголовки:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">halt</span> <span class="mi">402</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/plain'</span><span class="p">},</span> <span class="s1">'revenge'</span>
</code></pre>
</div>

<p>И, конечно, можно использовать шаблоны с <code class="highlighter-rouge">halt</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">halt</span> <span class="n">erb</span><span class="p">(</span><span class="ss">:error</span><span class="p">)</span>
</code></pre>
</div>

<h3>Передача</h3>

<p>Маршрут может передать обработку запроса следующему совпадающему маршруту
используя метод <code class="highlighter-rouge">pass</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/guess/:who'</span> <span class="k">do</span>
  <span class="n">pass</span> <span class="k">unless</span> <span class="n">params</span><span class="p">[</span><span class="s1">'who'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'Frank'</span>
  <span class="s1">'You got me!'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/guess/*'</span> <span class="k">do</span>
  <span class="s1">'You missed!'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Блок маршрута сразу же прерывается, а контроль переходит к следующему
совпадающему маршруту. Если соответствующий маршрут не найден, то ответом на
запрос будет 404.</p>

<h3>Вызов другого маршрута</h3>

<p>Иногда <code class="highlighter-rouge">pass</code> не подходит, например, если вы хотите получить результат вызова
другого обработчика маршрута. В таком случае просто используйте <code class="highlighter-rouge">call</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">call</span> <span class="n">env</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="s2">"PATH_INFO"</span> <span class="o">=&gt;</span> <span class="s1">'/bar'</span><span class="p">)</span>
  <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:upcase</span><span class="p">)]</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/bar'</span> <span class="k">do</span>
  <span class="s2">"bar"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Обратите внимание на то, что в предыдущем примере можно облегчить тестирование и
повысить производительность, перенеся <code class="highlighter-rouge">"bar"</code> в метод-помощник, используемый и в
<code class="highlighter-rouge">/foo</code>, и в <code class="highlighter-rouge">/bar</code>.</p>

<p>Если вы хотите, чтобы запрос был отправлен в тот же экземпляр приложения, 
а не в его копию, используйте <code class="highlighter-rouge">call!</code> вместо <code class="highlighter-rouge">call</code>.</p>

<p>Если хотите узнать больше о <code class="highlighter-rouge">call</code>, смотрите спецификацию Rack.</p>

<h3>Установка тела, статус кода и заголовков ответа</h3>

<p>Хорошим тоном является установка кода состояния HTTP и тела ответа в
возвращаемом значении обработчика маршрута. Тем не менее, в некоторых
ситуациях вам, возможно, понадобится задать тело ответа в произвольной точке
потока исполнения. Вы можете сделать это при помощи метода-помощника <code class="highlighter-rouge">body</code>.
Если вы задействуете метод <code class="highlighter-rouge">body</code>, то вы можете использовать его и в
дальнейшем, чтобы получить доступ к телу ответа:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">body</span> <span class="s2">"bar"</span>
<span class="k">end</span>

<span class="n">after</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="n">body</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Также можно передать блок в метод <code class="highlighter-rouge">body</code>, который затем будет вызван
обработчиком Rack (такой подход может быть использован для реализации
потокового ответа, см. <a href="#%D0%92%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D0%BC%D1%8B%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">“Возвращаемые значения”</a>).</p>

<p>Аналогично вы можете установить код ответа и его заголовки:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">status</span> <span class="mi">418</span>
  <span class="n">headers</span> <span class="p">\</span>
    <span class="s2">"Allow"</span>   <span class="o">=&gt;</span> <span class="s2">"BREW, POST, GET, PROPFIND, WHEN"</span><span class="p">,</span>
    <span class="s2">"Refresh"</span> <span class="o">=&gt;</span> <span class="s2">"Refresh: 20; https://ietf.org/rfc/rfc2324.txt"</span>
  <span class="n">body</span> <span class="s2">"I'm a tea pot!"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Как и <code class="highlighter-rouge">body</code>, методы <code class="highlighter-rouge">headers</code> и <code class="highlighter-rouge">status</code>, вызванные без аргументов,
возвращают свои текущие значения.</p>

<h3>Потоковые ответы</h3>

<p>Иногда требуется начать отправлять данные клиенту прямо в процессе
генерирования частей этих данных. В особых случаях требуется постоянно
отправлять данные до тех пор, пока клиент не закроет соединение. Вы можете
использовать метод <code class="highlighter-rouge">stream</code> вместо разработки собственных “обёрток”.</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">stream</span> <span class="k">do</span> <span class="o">|</span><span class="n">out</span><span class="o">|</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s2">"It's gonna be legen -</span><span class="se">\n</span><span class="s2">"</span>
    <span class="nb">sleep</span> <span class="mi">0</span><span class="o">.</span><span class="mi">5</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s2">" (wait for it) </span><span class="se">\n</span><span class="s2">"</span>
    <span class="nb">sleep</span> <span class="mi">1</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s2">"- dary!</span><span class="se">\n</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Это позволяет вам реализовать стриминговые API,
<a href="https://w3c.github.io/eventsource/">Server Sent Events</a>,
и может служить основой для <a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a>.
Также такой подход можно использовать для увеличения производительности в том случае,
когда какая-то часть контента (а не весь) зависит от медленного ресурса.</p>

<p>Обратите внимание на то, что возможности стриминга, особенно количество одновременно
обслуживаемых запросов, очень сильно зависят от используемого веб-сервера.
Некоторые серверы могут и вовсе не поддерживать стриминг. Если сервер не
поддерживает стриминг, то все данные будут отправлены за один раз сразу после
того, как блок, переданный в <code class="highlighter-rouge">stream</code>, завершится. Стриминг вообще не работает
при использовании Shotgun.</p>

<p>Если метод используется с параметром <code class="highlighter-rouge">keep_open</code>, то он не будет вызывать
<code class="highlighter-rouge">close</code> у объекта потока, что позволит вам закрыть его позже в любом другом
месте. Это работает только с событийными серверами, например, с Thin и
Rainbows. Другие же серверы всё равно будут закрывать поток:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># long polling</span>

<span class="n">set</span> <span class="ss">:server</span><span class="p">,</span> <span class="ss">:thin</span>
<span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">get</span> <span class="s1">'/subscribe'</span> <span class="k">do</span>
  <span class="c1"># регистрация клиента в событиях сервера</span>
  <span class="n">stream</span><span class="p">(</span><span class="ss">:keep_open</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">out</span><span class="o">|</span>
    <span class="n">connections</span> <span class="o">&lt;&lt;</span> <span class="n">out</span>
    <span class="c1"># удаление "мёртвых клиентов"</span>
    <span class="n">connections</span><span class="p">.</span><span class="nf">reject!</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:closed?</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">post</span> <span class="s1">'/:message'</span> <span class="k">do</span>
  <span class="n">connections</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">out</span><span class="o">|</span>
    <span class="c1"># уведомить клиента о новом сообщении</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">params</span><span class="p">[</span><span class="s1">'message'</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span>

    <span class="c1"># указать клиенту на необходимость снова соединиться</span>
    <span class="n">out</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>

  <span class="c1"># допуск</span>
  <span class="s2">"message received"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Также клиент может закрыть соединение при попытке записи в сокет. В связи с 
этим рекомендуется выполнить проверку <code class="highlighter-rouge">out.closed?</code> прежде, чем пытаться произвести запись.</p>

<h3>Логирование</h3>

<p>В области видимости запроса метод <code class="highlighter-rouge">logger</code> предоставляет доступ к экземпляру
<code class="highlighter-rouge">Logger</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">logger</span><span class="p">.</span><span class="nf">info</span> <span class="s2">"loading data"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Этот логер автоматически учитывает ваши настройки логирования в Rack. Если
логирование выключено, то этот метод вернет пустой (dummy) объект, поэтому вы
можете смело использовать его в маршрутах и фильтрах.</p>

<p>Обратите внимание на то, что логирование включено по умолчанию только для
<code class="highlighter-rouge">Sinatra::Application</code>. Если ваше приложение является подклассом <code class="highlighter-rouge">Sinatra::Base</code>, то
вы, скорее всего, захотите включить его вручную:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">configure</span> <span class="ss">:production</span><span class="p">,</span> <span class="ss">:development</span> <span class="k">do</span>
    <span class="n">enable</span> <span class="ss">:logging</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Чтобы избежать использования любой логирующей “прослойки”, задайте опции
<code class="highlighter-rouge">logging</code> значение <code class="highlighter-rouge">nil</code>. При этом не забывайте, что в такой ситуации
<code class="highlighter-rouge">logger</code> будет возвращать <code class="highlighter-rouge">nil</code>. Чаще всего так делают, когда задают свой собственный
логер. Sinatra будет использовать то, что находится в <code class="highlighter-rouge">env['rack.logger']</code>.</p>

<h3>Mime-типы</h3>

<p>Когда вы используете <code class="highlighter-rouge">send_file</code> или статические файлы, у вас могут быть
mime-типы, которые Sinatra не понимает по умолчанию. Используйте <code class="highlighter-rouge">mime_type</code>
для их регистрации по расширению файла:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">configure</span> <span class="k">do</span>
  <span class="n">mime_type</span> <span class="ss">:foo</span><span class="p">,</span> <span class="s1">'text/foo'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Вы также можете использовать это в методе-помощнике <code class="highlighter-rouge">content_type</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">content_type</span> <span class="ss">:foo</span>
  <span class="s2">"foo foo foo"</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Генерирование URL</h3>

<p>Чтобы сформировать URL, вам следует использовать метод <code class="highlighter-rouge">url</code>, например, в Haml:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="o">%</span><span class="n">a</span><span class="p">{</span><span class="ss">:href</span> <span class="o">=&gt;</span> <span class="n">url</span><span class="p">(</span><span class="s1">'/foo'</span><span class="p">)}</span> <span class="n">foo</span>
</code></pre>
</div>

<p>Этот метод учитывает обратные прокси и маршрутизаторы Rack, если они
присутствуют.</p>

<p>Наряду с <code class="highlighter-rouge">url</code> вы можете использовать <code class="highlighter-rouge">to</code> (смотрите пример ниже).</p>

<h3>Перенаправление (редирект)</h3>

<p>Вы можете перенаправить браузер пользователя при помощи метода <code class="highlighter-rouge">redirect</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">redirect</span> <span class="n">to</span><span class="p">(</span><span class="s1">'/bar'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Любые дополнительные параметры используются по аналогии с аргументами метода
<code class="highlighter-rouge">halt</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">redirect</span> <span class="n">to</span><span class="p">(</span><span class="s1">'/bar'</span><span class="p">),</span> <span class="mi">303</span>
<span class="n">redirect</span> <span class="s1">'http://www.google.com/'</span><span class="p">,</span> <span class="s1">'wrong place, buddy'</span>
</code></pre>
</div>

<p>Вы также можете перенаправить пользователя обратно на страницу, с которой он
пришёл, при помощи <code class="highlighter-rouge">redirect back</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="s2">"&lt;a href='/bar'&gt;do something&lt;/a&gt;"</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/bar'</span> <span class="k">do</span>
  <span class="n">do_something</span>
  <span class="n">redirect</span> <span class="n">back</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Для того, чтобы передать какие-либо параметры вместе с перенаправлением,
добавьте их в строку запроса:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">redirect</span> <span class="n">to</span><span class="p">(</span><span class="s1">'/bar?sum=42'</span><span class="p">)</span>
</code></pre>
</div>

<p>либо используйте сессию:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">enable</span> <span class="ss">:sessions</span>

<span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">session</span><span class="p">[</span><span class="ss">:secret</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'foo'</span>
  <span class="n">redirect</span> <span class="n">to</span><span class="p">(</span><span class="s1">'/bar'</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/bar'</span> <span class="k">do</span>
  <span class="n">session</span><span class="p">[</span><span class="ss">:secret</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Управление кэшированием</h3>

<p>Установка корректных заголовков — основа правильного HTTP кэширования.</p>

<p>Вы можете легко выставить заголовок Cache-Control следующим образом:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">cache_control</span> <span class="ss">:public</span>
  <span class="s2">"cache it!"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Совет: задавайте кэширование в <code class="highlighter-rouge">before</code>-фильтре:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">before</span> <span class="k">do</span>
  <span class="n">cache_control</span> <span class="ss">:public</span><span class="p">,</span> <span class="ss">:must_revalidate</span><span class="p">,</span> <span class="ss">:max_age</span> <span class="o">=&gt;</span> <span class="mi">60</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Если вы используете метод <code class="highlighter-rouge">expires</code> для задания соответствующего заголовка, то
<code class="highlighter-rouge">Cache-Control</code> будет выставлен автоматически:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">before</span> <span class="k">do</span>
  <span class="n">expires</span> <span class="mi">500</span><span class="p">,</span> <span class="ss">:public</span><span class="p">,</span> <span class="ss">:must_revalidate</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Чтобы использовать кэширование правильно, вам стоит подумать о
применении <code class="highlighter-rouge">etag</code> или <code class="highlighter-rouge">last_modified</code>. Рекомендуется использовать эти
методы-помощники <em>до</em> выполнения ресурсоёмких вычислений, так как они
немедленно отправят ответ клиенту в том случае, если текущая версия
уже присутствует в их кэше:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s2">"/article/:id"</span> <span class="k">do</span>
  <span class="vi">@article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">find</span> <span class="n">params</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span>
  <span class="n">last_modified</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">updated_at</span>
  <span class="n">etag</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">sha1</span>
  <span class="n">erb</span> <span class="ss">:article</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Также вы можете использовать
<a href="https://en.wikipedia.org/wiki/HTTP_ETag#Strong_and_weak_validation">weak ETag</a>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">etag</span> <span class="vi">@article</span><span class="p">.</span><span class="nf">sha1</span><span class="p">,</span> <span class="ss">:weak</span>
</code></pre>
</div>

<p>Эти методы-помощники не станут ничего кэшировать, однако они дадут
необходимую информацию для вашего кэша. Если вы ищете лёгкое решение для
кэширования, попробуйте <a href="https://github.com/rtomayko/rack-cache#readme">rack-cache</a>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s2">"rack/cache"</span>
<span class="nb">require</span> <span class="s2">"sinatra"</span>

<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Cache</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">cache_control</span> <span class="ss">:public</span><span class="p">,</span> <span class="ss">:max_age</span> <span class="o">=&gt;</span> <span class="mi">36000</span>
  <span class="nb">sleep</span> <span class="mi">5</span>
  <span class="s2">"hello"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Используйте опцию <code class="highlighter-rouge">:static_cache_control</code> (см. ниже), чтобы добавить заголовок
<code class="highlighter-rouge">Cache-Control</code> к статическим файлам.</p>

<p>В соответствии с RFC 2616 ваше приложение должно вести себя по-разному, когда
заголовки If-Match или If-None-Match имеют значение <code class="highlighter-rouge">*</code>, в зависимости от
того, существует или нет запрашиваемый ресурс. Sinatra предполагает, что
ресурсы, к которым обращаются при помощи безопасных (GET) и идемпотентных (PUT)
методов, уже существуют, а остальные ресурсы (к которым обращаются, например,
при помощи POST) считает новыми. Вы можете изменить данное поведение при помощи
опции <code class="highlighter-rouge">:new_resource</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/create'</span> <span class="k">do</span>
  <span class="n">etag</span> <span class="s1">''</span><span class="p">,</span> <span class="ss">:new_resource</span> <span class="o">=&gt;</span> <span class="kp">true</span>
  <span class="no">Article</span><span class="p">.</span><span class="nf">create</span>
  <span class="n">erb</span> <span class="ss">:new_article</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Если вы хотите использовать weak ETag, задайте опцию <code class="highlighter-rouge">:kind</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">etag</span> <span class="s1">''</span><span class="p">,</span> <span class="ss">:new_resource</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">:kind</span> <span class="o">=&gt;</span> <span class="ss">:weak</span>
</code></pre>
</div>

<h3>Отправка файлов</h3>

<p>Для отправки файлов пользователю вы можете использовать метод <code class="highlighter-rouge">send_file</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">send_file</span> <span class="s1">'foo.png'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Этот метод имеет несколько опций:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">send_file</span> <span class="s1">'foo.png'</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:jpg</span>
</code></pre>
</div>

<p>Возможные опции:</p>

<dl>
  <dt>filename</dt>
    <dd>имя файла, по умолчанию: реальное имя файла.</dd>

  <dt>last_modified</dt>
    <dd>значение для заголовка Last-Modified, по умолчанию: mtime (время
        изменения) файла.</dd>

  <dt>type</dt>
    <dd>тип файла, по умолчанию: определяется по расширению файла.</dd>

  <dt>disposition</dt>
    <dd>
    используется для заголовка Content-Disposition, возможные значения: <tt>nil</tt>
      (по умолчанию), <tt>:attachment</tt> и <tt>:inline</tt>
    </dd>

  <dt>length</dt>
    <dd>значения для заголовка Content-Length, по умолчанию: размер файла.</dd>

  <dt>status</dt>
    <dd>
    Код ответа. Полезно в том случае, когда отсылается статический файл в качестве
    страницы с сообщением об ошибке. Если поддерживается обработчик Rack, будут использоваться 
    другие средства, кроме потоковой передачи из процесса Ruby. Если вы используете 
    этот вспомогательный метод, Sinatra автоматически обрабатывает запросы диапазона.
    </dd>
</dl>

<h3>Доступ к объекту запроса</h3>

<p>Объект входящего запроса доступен на уровне обработки запроса (в фильтрах,
маршрутах, обработчиках ошибок) при помощи <code class="highlighter-rouge">request</code> метода:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># приложение запущено на http://example.com/example</span>
<span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
  <span class="n">t</span> <span class="o">=</span> <span class="sx">%w[text/css text/html application/javascript]</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">accept</span>              <span class="c1"># ['text/html', '*/*']</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">accept?</span> <span class="s1">'text/xml'</span>  <span class="c1"># true</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">preferred_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>   <span class="c1"># 'text/html'</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">body</span>                <span class="c1"># тело запроса, посланное клиентом (см. ниже)</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">scheme</span>              <span class="c1"># "http"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">script_name</span>         <span class="c1"># "/example"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">path_info</span>           <span class="c1"># "/foo"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">port</span>                <span class="c1"># 80</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">request_method</span>      <span class="c1"># "GET"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">query_string</span>        <span class="c1"># ""</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">content_length</span>      <span class="c1"># длина тела запроса</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">media_type</span>          <span class="c1"># медиатип тела запроса</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">host</span>                <span class="c1"># "example.com"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">get?</span>                <span class="c1"># true (есть аналоги для других методов HTTP)</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">form_data?</span>          <span class="c1"># false</span>
  <span class="n">request</span><span class="p">[</span><span class="s2">"some_param"</span><span class="p">]</span>       <span class="c1"># значение параметра some_param. Шорткат для хэша params</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">referrer</span>            <span class="c1"># источник запроса клиента либо '/'</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">user_agent</span>          <span class="c1"># user agent (используется для :agent условия)</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">cookies</span>             <span class="c1"># хэш, содержащий cookies браузера</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">xhr?</span>                <span class="c1"># является ли запрос ajax запросом?</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">url</span>                 <span class="c1"># "http://example.com/example/foo"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">path</span>                <span class="c1"># "/example/foo"</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">ip</span>                  <span class="c1"># IP-адрес клиента</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">secure?</span>             <span class="c1"># false (true, если запрос сделан через SSL)</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">forwarded?</span>          <span class="c1"># true (если сервер работает за обратным прокси)</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">env</span>                 <span class="c1"># "сырой" env хэш, полученный Rack</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Некоторые опции, такие как <code class="highlighter-rouge">script_name</code> или <code class="highlighter-rouge">path_info</code>, доступны для
модификации:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">before</span> <span class="p">{</span> <span class="n">request</span><span class="p">.</span><span class="nf">path_info</span> <span class="o">=</span> <span class="s2">"/"</span> <span class="p">}</span>

<span class="n">get</span> <span class="s2">"/"</span> <span class="k">do</span>
  <span class="s2">"all requests end up here"</span>
<span class="k">end</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">request.body</code> является IO или StringIO объектом:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">post</span> <span class="s2">"/api"</span> <span class="k">do</span>
  <span class="n">request</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">rewind</span>  <span class="c1"># в случае, если кто-то уже прочитал тело запроса</span>
  <span class="n">data</span> <span class="o">=</span> <span class="no">JSON</span><span class="p">.</span><span class="nf">parse</span> <span class="n">request</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">read</span>
  <span class="s2">"Hello </span><span class="si">#{</span><span class="n">data</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Вложения</h3>

<p>Вы можете использовать метод <code class="highlighter-rouge">attachment</code>, чтобы сообщить браузеру о том,
что ответ сервера должен быть сохранён на диск, а не отображён:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">attachment</span>
  <span class="s2">"store it!"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Вы также можете указать имя файла:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">attachment</span> <span class="s2">"info.txt"</span>
  <span class="s2">"store it!"</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Работа со временем и датами</h3>

<p>Sinatra предлагает метод-помощник <code class="highlighter-rouge">time_for</code>, который из заданного значения
создает объект Time. Он также может конвертировать <code class="highlighter-rouge">DateTime</code>, <code class="highlighter-rouge">Date</code> и
схожие классы:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">pass</span> <span class="k">if</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">&gt;</span> <span class="n">time_for</span><span class="p">(</span><span class="s1">'Dec 23, 2016'</span><span class="p">)</span>
  <span class="s2">"still time"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Этот метод используется внутри Sinatra методами <code class="highlighter-rouge">expires</code>, <code class="highlighter-rouge">last_modified</code> и
им подобными. Поэтому вы легко можете изменить и дополнить поведение этих методов,
переопределив <code class="highlighter-rouge">time_for</code> в своём приложении:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">time_for</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">value</span>
    <span class="k">when</span> <span class="ss">:yesterday</span> <span class="k">then</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>
    <span class="k">when</span> <span class="ss">:tomorrow</span>  <span class="k">then</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">+</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>
    <span class="k">else</span> <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">last_modified</span> <span class="ss">:yesterday</span>
  <span class="n">expires</span> <span class="ss">:tomorrow</span>
  <span class="s2">"hello"</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Поиск файлов шаблонов</h3>

<p>Для поиска шаблонов и их последующего рендеринга используется метод
<code class="highlighter-rouge">find_template</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">find_template</span> <span class="n">settings</span><span class="p">.</span><span class="nf">views</span><span class="p">,</span> <span class="s1">'foo'</span><span class="p">,</span> <span class="no">Tilt</span><span class="p">[</span><span class="ss">:haml</span><span class="p">]</span> <span class="k">do</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">"could be </span><span class="si">#{</span><span class="n">file</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Это не слишком полезный пример. Зато полезен тот факт, что вы можете
переопределить этот метод, чтобы использовать свой собственный механизм
поиска. Например, если вы хотите, чтобы можно было использовать несколько
директорий с шаблонами:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:views</span><span class="p">,</span> <span class="p">[</span><span class="s1">'views'</span><span class="p">,</span> <span class="s1">'templates'</span><span class="p">]</span>

<span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">find_template</span><span class="p">(</span><span class="n">views</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="no">Array</span><span class="p">(</span><span class="n">views</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span> <span class="k">super</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Другой пример, в котором используются разные директории для движков
рендеринга:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:views</span><span class="p">,</span> <span class="ss">:sass</span> <span class="o">=&gt;</span> <span class="s1">'views/sass'</span><span class="p">,</span> <span class="ss">:haml</span> <span class="o">=&gt;</span> <span class="s1">'templates'</span><span class="p">,</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="s1">'views'</span>

<span class="n">helpers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="nf">find_template</span><span class="p">(</span><span class="n">views</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">views</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="o">|</span> <span class="n">engine</span> <span class="o">==</span> <span class="no">Tilt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">}</span>
    <span class="n">folder</span> <span class="o">||=</span> <span class="n">views</span><span class="p">[</span><span class="ss">:default</span><span class="p">]</span>
    <span class="k">super</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Вы можете легко вынести этот код в расширение и поделиться им с остальными!</p>

<p>Обратите внимание на тот факт, что <code class="highlighter-rouge">find_template</code> не проверяет, существует ли
файл на самом деле, а вызывает заданный блок для всех возможных путей. Дело тут не в
производительности, а в том, что <code class="highlighter-rouge">render</code> вызовет <code class="highlighter-rouge">break</code> как только файл
будет найден. Содержимое и местонахождение шаблонов будет закэшировано в том случае,
если приложение запущено не в режиме разработки (<code class="highlighter-rouge">set :environment, :development</code>). 
Вы должны помнить об этих нюансах, если пишите по-настоящему “сумасшедший” 
метод.</p>

<h2>Конфигурация</h2>

<p>Этот блок исполняется один раз при старте в любом окружении (environment):</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">configure</span> <span class="k">do</span>
  <span class="c1"># задание одной опции</span>
  <span class="n">set</span> <span class="ss">:option</span><span class="p">,</span> <span class="s1">'value'</span>

  <span class="c1"># устанавливаем несколько опций</span>
  <span class="n">set</span> <span class="ss">:a</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="ss">:b</span> <span class="o">=&gt;</span> <span class="mi">2</span>

  <span class="c1"># то же самое, что и `set :option, true`</span>
  <span class="n">enable</span> <span class="ss">:option</span>

  <span class="c1"># то же самое, что и `set :option, false`</span>
  <span class="n">disable</span> <span class="ss">:option</span>

  <span class="c1"># у вас могут быть "динамические" опции с блоками</span>
  <span class="n">set</span><span class="p">(</span><span class="ss">:css_dir</span><span class="p">)</span> <span class="p">{</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">views</span><span class="p">,</span> <span class="s1">'css'</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Следующий пример будет выполнен только тогда, когда окружение
(переменная <code class="highlighter-rouge">APP_ENV</code>) будет задана как <code class="highlighter-rouge">:production</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">configure</span> <span class="ss">:production</span> <span class="k">do</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
</div>

<p>Следующий код будет выполнен в том случае, когда окружение
будет задано как <code class="highlighter-rouge">:production</code> или <code class="highlighter-rouge">:test</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">configure</span> <span class="ss">:production</span><span class="p">,</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
</div>

<p>Вы можете получить доступ к этим опциям при помощи метода <code class="highlighter-rouge">settings</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">configure</span> <span class="k">do</span>
  <span class="n">set</span> <span class="ss">:foo</span><span class="p">,</span> <span class="s1">'bar'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="n">settings</span><span class="p">.</span><span class="nf">foo?</span> <span class="c1"># =&gt; true</span>
  <span class="n">settings</span><span class="p">.</span><span class="nf">foo</span>  <span class="c1"># =&gt; 'bar'</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
</div>

<h3>Настройка защиты от атак</h3>

<p>Sinatra использует
<a href="https://github.com/sinatra/sinatra/tree/master/rack-protection#readme">Rack::Protection</a> для защиты
приложения от простых атак. Вы можете легко выключить эту защиту (что сделает
ваше приложение чрезвычайно уязвимым к большому числу различных уязвимостей):</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">disable</span> <span class="ss">:protection</span>
</code></pre>
</div>

<p>Чтобы отключить какой-либо конкретный уровень защиты, передайте хэш опций
в параметр <code class="highlighter-rouge">protection</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:protection</span><span class="p">,</span> <span class="ss">:except</span> <span class="o">=&gt;</span> <span class="ss">:path_traversal</span>
</code></pre>
</div>

<p>Вы также можете отключить сразу несколько уровней защиты:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:protection</span><span class="p">,</span> <span class="ss">:except</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:path_traversal</span><span class="p">,</span> <span class="ss">:session_hijacking</span><span class="p">]</span>
</code></pre>
</div>

<p>По умолчанию Sinatra будет устанавливать <code class="highlighter-rouge">session based</code> защиту только если 
включена опция <code class="highlighter-rouge">:sessions</code>. См. <a href="#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%B9">“Использование сессий””</a>.
Иногда вы захотите  настроить сессии “вне” приложения Sinatra, например, в
config.ru или при помощи отдельного экземпляра <code class="highlighter-rouge">Rack::Builder</code>. В таком случае
вы также можете настроить <code class="highlighter-rouge">session based</code> защиту, передав опцию <code class="highlighter-rouge">:session</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:protection</span><span class="p">,</span> <span class="ss">:session</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</code></pre>
</div>

<h3>Доступные настройки</h3>

<dl>
  <dt>absolute_redirects</dt>
    <dd>
      если отключено, то Sinatra будет позволять использование относительных
      перенаправлений, но при этом перестанет соответствовать RFC 2616 (HTTP
      1.1), который разрешает только абсолютные перенаправления.
    </dd>
    <dd>
      включайте эту опцию, если ваше приложение работает за обратным прокси,
      который настроен не совсем корректно. Обратите внимание на тот факт, что
      метод <tt>url</tt> всё равно будет генерировать абсолютные URL в том случае,
      если вы не передадите <tt>false</tt> вторым аргументом.
    </dd>
    <dd>отключено по умолчанию.</dd>

  <dt>add_charset</dt>
    <dd>
      mime-типы, к которым метод <tt>content_type</tt> будет автоматически добавлять
      информацию о кодировке. Вам следует добавлять значения к этой опции
      вместо её переопределения: <tt>settings.add_charset &lt;&lt; "application/foobar"</tt>
    </dd>

  <dt>app_file</dt>
    <dd>
      путь к главному файлу приложения, используется для нахождения корневой
      директории проекта, директорий с шаблонами и статическими файлами,
      вложенных шаблонов.
    </dd>

  <dt>bind</dt>
    <dd>
      используемый IP-адрес (по умолчанию: <tt>0.0.0.0</tt> <em>или</em>
      <tt>localhost</tt> если опция `environment` настроена на "development"). 
    Используется только встроенным сервером.
    </dd>

  <dt>default_encoding</dt>
    <dd>кодировка, если неизвестна (по умолчанию: <tt>"utf-8"</tt>).</dd>

  <dt>dump_errors</dt>
    <dd>отображать ошибки в логе.</dd>

  <dt>environment</dt>
    <dd>
      текущее окружение, по умолчанию, значение <tt>ENV['APP_ENV']</tt> или
      <tt>"development"</tt>, если <tt>ENV['APP_ENV']</tt> недоступна.
    </dd>

  <dt>logging</dt>
    <dd>использовать логер.</dd>

  <dt>lock</dt>
    <dd>
      создаёт блокировку для каждого запроса, которая гарантирует обработку
      только одного запроса в текущий момент времени в Ruby процессе.
    </dd>
    <dd>
      включайте в том случае, если ваше приложение не потокобезопасно (thread-safe).
      Отключено по умолчанию.
  </dd>

  <dt>method_override</dt>
    <dd>
      использовать "магический" параметр <tt>_method</tt> для поддержки
      PUT/DELETE форм в браузерах, которые не поддерживают данные методы.
    </dd>

  <dt>mustermann_opts</dt>
    <dd>
    хэш настроек по умолчанию для перехода к Mustermann.new при компиляции 
    маршрутов маршрутизации.
    </dd>

  <dt>port</dt>
    <dd>
      порт, на котором будет работать сервер. 
      Используется только встроенным сервером.
    </dd>

  <dt>prefixed_redirects</dt>
    <dd>
      добавлять или нет параметр <tt>request.script_name</tt> к редиректам, если не
      задан абсолютный путь. Таким образом, <tt>redirect '/foo'</tt> будет вести себя
      как <tt>redirect to('/foo')</tt>. Отключено по умолчанию.
    </dd>

  <dt>protection</dt>
    <dd>включена или нет защита от атак. Смотрите секцию защиты от атак выше.</dd>

  <dt>public_dir</dt>
    <dd>алиас для <tt>public_folder</tt>.</dd>

  <dt>public_folder</dt>
    <dd>
      путь к общедоступной директории, откуда будут раздаваться файлы.
      Используется, только если включена раздача статических файлов
      (см. опцию <tt>static</tt> ниже). Берётся из настройки <tt>app_file</tt>,
    если не установлена.
    </dd>

  <dt>quiet</dt>
    <dd>
      отключает журналы, созданные командами запуска и остановки Sinatra. 
      <tt>false</tt> по умолчанию.
    </dd>

  <dt>reload_templates</dt>
    <dd>
      перезагружать или нет шаблоны на каждый запрос. Включено в режиме
      разработки.
    </dd>

  <dt>root</dt>
    <dd>
    путь к корневой директории проекта. Берётся из настройки <tt>app_file</tt>,
    если не установлен.
    </dd>

  <dt>raise_errors</dt>
    <dd>
      выбрасывать исключения (будет останавливать приложение).
      По умолчанию включено только в окружении <tt>"test"</tt>.
    </dd>

  <dt>run</dt>
    <dd>
      если включено, Sinatra будет самостоятельно запускать веб-сервер. Не
      включайте, если используете rackup или аналогичные средства.
    </dd>

  <dt>running</dt>
    <dd>работает ли сейчас встроенный сервер? Не меняйте эту опцию!</dd>

  <dt>server</dt>
    <dd>
      сервер или список серверов, которые следует использовать в качестве
      встроенного сервера. Порядок задаёт приоритет, по умолчанию зависит 
    от реализации Ruby.
    </dd>

  <dt>server_settings</dt>
    <dd>
      Если вы используете в качестве сервера WEBrick, например для работы в
      режиме разработки, то вы можете передать набор опций для <tt>server_settings</tt>,
      таких как <tt>SSLEnable</tt> или <tt>SSLVerifyClient</tt>. Тем не менее, такие
      серверы как Puma или Thin не поддерживают эти параметры, поэтому вы можете
      устанавливать <tt>server_settings</tt> указав его как метод при вызове
      <tt>configure</tt>.
    </dd>

  <dt>sessions</dt>
    <dd>
      включить сессии на основе кук (cookie) на базе <tt>Rack::Session::Cookie</tt>.
      Смотрите раздел "Использование сессий" выше.
    </dd>

  <dt>session_store</dt>
    <dd>
      используемая Rack "прослойка" для сессии. По умолчанию <tt>Rack::Session::Cookie</tt>. 
      Смотрите раздел "Использование сессий" выше.
    </dd>

  <dt>show_exceptions</dt>
    <dd>
      показывать исключения/стек вызовов (stack trace) в браузере. По умолчанию
      включено только в окружении <tt>"development"</tt>.
    </dd>
    <dd>
      может также быть установлено в <tt>:after_handler</tt> для запуска специфичной 
      для приложения обработки ошибок, перед показом трассировки стека в браузере.
    </dd>

  <dt>static</dt>
    <dd>указывает, должна ли Sinatra осуществлять раздачу статических файлов.</dd>
    <dd>Отключите, если используете какой-либо веб-сервер для этой цели.</dd>
    <dd>Отключение значительно улучшит производительность приложения.</dd>
    <dd>По умолчанию включено в классических и отключено в модульных приложениях.</dd>

  <dt>static_cache_control</dt>
    <dd>
      когда Sinatra раздаёт статические файлы, используйте эту опцию для того,
      чтобы добавить им заголовок <tt>Cache-Control</tt>. Для этого используется
      метод-помощник <tt>cache_control</tt>. По умолчанию отключено.
    </dd>
    <dd>
      используйте массив, когда надо задать несколько значений:
      <tt>set :static_cache_control, [:public, :max_age =&gt; 300]</tt>
    </dd>

  <dt>threaded</dt>
    <dd>
      если включено, то Thin будет использовать <tt>EventMachine.defer</tt> для
      обработки запросов.
    </dd>

  <dt>traps</dt>
    <dd>указывает, должна ли Sinatra обрабатывать системные сигналы.&lt;/tt&gt;</dd>

  <dt>views</dt>
    <dd>
    путь к директории с шаблонами. Берётся из настройки <tt>app_file</tt> в том
    случае, если не установлен.
    </dd>

  <dt>x_cascade</dt>
    <dd>
      Указывает, необходимо ли устанавливать заголовок X-Cascade если никакие маршруты не совпадают.
      <tt>true</tt> по умолчанию.
    </dd>
</dl>

<h2>Режим, окружение</h2>

<p>Есть 3 предопределённых режима работы приложения (окружения): <code class="highlighter-rouge">"development"</code>,
<code class="highlighter-rouge">"production"</code> и <code class="highlighter-rouge">"test"</code>. Режим может быть задан через переменную окружения <code class="highlighter-rouge">APP_ENV</code>.
Значение по умолчанию — <code class="highlighter-rouge">"development"</code>. В этом режиме работы все шаблоны
перезагружаются между запросами, а также задаются специальные обработчики
<code class="highlighter-rouge">not_found</code> и <code class="highlighter-rouge">error</code>, чтобы вы могли увидеть стек вызовов. В окружениях
<code class="highlighter-rouge">"production"</code> и <code class="highlighter-rouge">"test"</code> шаблоны по умолчанию кэшируются.</p>

<p>Для запуска приложения в определённом окружении установите переменную 
окружения <code class="highlighter-rouge">APP_ENV</code>:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code><span class="nv">APP_ENV</span><span class="o">=</span>production ruby my_app.rb
</code></pre>
</div>

<p>Вы можете использовать предопределённые методы <code class="highlighter-rouge">development?</code>, <code class="highlighter-rouge">test?</code> и
<code class="highlighter-rouge">production?</code>, чтобы определить текущее окружение.</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="k">if</span> <span class="n">settings</span><span class="p">.</span><span class="nf">development?</span>
    <span class="s2">"development!"</span>
  <span class="k">else</span>
    <span class="s2">"not development!"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h2>Обработка ошибок</h2>

<p>Обработчики ошибок исполняются в том же контексте, что и маршруты и
<code class="highlighter-rouge">before</code>-фильтры, а это означает, что всякие прелести вроде <code class="highlighter-rouge">haml</code>, <code class="highlighter-rouge">erb</code>,
<code class="highlighter-rouge">halt</code> и т.д. доступны и им.</p>

<h3>Not Found</h3>

<p>В случае возникновения исключения <code class="highlighter-rouge">Sinatra::NotFound</code> или возврата кода ответа 404
будет вызван обработчик <code class="highlighter-rouge">not_found</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">not_found</span> <span class="k">do</span>
  <span class="s1">'This is nowhere to be found.'</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Error</h3>

<p>Обработчик ошибок <code class="highlighter-rouge">error</code> будет вызван тогда, когда исключение выброшено из блока
маршрута либо из фильтра. Тем не менее, обратите внимание на то, что в режиме разработки
он будет запускаться только в том случае, если вы установите опцию “show exceptions” 
на <code class="highlighter-rouge">: after_handler</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">set</span> <span class="ss">:show_exceptions</span><span class="p">,</span> <span class="ss">:after_handler</span>
</code></pre>
</div>

<p>Объект-исключение доступен как переменная <code class="highlighter-rouge">sinatra.error</code> в Rack:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">error</span> <span class="k">do</span>
  <span class="s1">'Sorry there was a nasty error - '</span> <span class="o">+</span> <span class="n">env</span><span class="p">[</span><span class="s1">'sinatra.error'</span><span class="p">].</span><span class="nf">message</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Пользовательские ошибки:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">error</span> <span class="no">MyCustomError</span> <span class="k">do</span>
  <span class="s1">'So what happened was...'</span> <span class="o">+</span> <span class="n">env</span><span class="p">[</span><span class="s1">'sinatra.error'</span><span class="p">].</span><span class="nf">message</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Тогда, если это возникнет:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="k">raise</span> <span class="no">MyCustomError</span><span class="p">,</span> <span class="s1">'something bad'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>То вы получите:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>So what happened was... something bad
</code></pre>
</div>

<p>Также вы можете установить обработчик ошибок для кода состояния HTTP:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">error</span> <span class="mi">403</span> <span class="k">do</span>
  <span class="s1">'Access forbidden'</span>
<span class="k">end</span>

<span class="n">get</span> <span class="s1">'/secret'</span> <span class="k">do</span>
  <span class="mi">403</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Либо набора кодов:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">error</span> <span class="mi">400</span><span class="p">.</span><span class="nf">.</span><span class="mi">510</span> <span class="k">do</span>
  <span class="s1">'Boom'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Sinatra устанавливает специальные обработчики <code class="highlighter-rouge">not_found</code> и <code class="highlighter-rouge">error</code>, когда
приложение запущено в режиме разработки (окружение <code class="highlighter-rouge">:development</code>) чтобы 
отображать информативные трассировки стека и дополнительную информацию об отладке 
в вашем браузере.</p>

<h2>Rack “прослойки”</h2>

<p>Sinatra использует <a href="https://rack.github.io/">Rack</a> - минимальный стандартный
интерфейс для веб-фреймворков на Ruby. Одной из самых интересных для
разработчиков возможностей Rack является поддержка “прослоек” (“middleware”) —
компонентов, находящихся “между” сервером и вашим приложением, которые
отслеживают и/или манипулируют HTTP запросами/ответами для предоставления
различной функциональности.</p>

<p>Sinatra позволяет очень просто создавать пайплайны из подобных Rack “прослоек”
при помощи метода <code class="highlighter-rouge">use</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra'</span>
<span class="nb">require</span> <span class="s1">'my_custom_middleware'</span>

<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Lint</span>
<span class="n">use</span> <span class="no">MyCustomMiddleware</span>

<span class="n">get</span> <span class="s1">'/hello'</span> <span class="k">do</span>
  <span class="s1">'Hello World'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Семантика <code class="highlighter-rouge">use</code> идентична той, что определена для
<a href="http://www.rubydoc.info/github/rack/rack/master/Rack/Builder">Rack::Builder</a> DSL
(чаще всего используется в rackup файлах). Так, например, метод <code class="highlighter-rouge">use</code> принимает как
множественные переменные, так и блоки:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Auth</span><span class="o">::</span><span class="no">Basic</span> <span class="k">do</span> <span class="o">|</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="o">|</span>
  <span class="n">username</span> <span class="o">==</span> <span class="s1">'admin'</span> <span class="o">&amp;&amp;</span> <span class="n">password</span> <span class="o">==</span> <span class="s1">'secret'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Rack распространяется с различными стандартными “прослойками” для логирования,
отладки, маршрутизации URL, аутентификации, обработки сессий. Sinatra
использует многие из этих компонентов автоматически, основываясь на
конфигурации, чтобы вам не приходилось подключать их при помощи <code class="highlighter-rouge">use</code> вручную.</p>

<p>Вы можете найти полезные прослойки в
<a href="https://github.com/rack/rack/tree/master/lib/rack">rack</a>,
<a href="https://github.com/rack/rack-contrib#readme">rack-contrib</a>,
или в <a href="https://github.com/rack/rack/wiki/List-of-Middleware">Rack wiki</a>.</p>

<h2>Тестирование</h2>

<p>Тесты для Sinatra приложений могут быть написаны при помощи любых библиотек или
фреймворков, поддерживающих тестирование Rack. Разработчики гема Sinatra рекомендуют
использовать <a href="http://www.rubydoc.info/github/brynary/rack-test/master/frames">Rack::Test</a>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'my_sinatra_app'</span>
<span class="nb">require</span> <span class="s1">'minitest/autorun'</span>
<span class="nb">require</span> <span class="s1">'rack/test'</span>

<span class="k">class</span> <span class="nc">MyAppTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
  <span class="kp">include</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Test</span><span class="o">::</span><span class="no">Methods</span>

  <span class="k">def</span> <span class="nf">app</span>
    <span class="no">Sinatra</span><span class="o">::</span><span class="no">Application</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_my_default</span>
    <span class="n">get</span> <span class="s1">'/'</span>
    <span class="n">assert_equal</span> <span class="s1">'Hello World!'</span><span class="p">,</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">body</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_with_params</span>
    <span class="n">get</span> <span class="s1">'/meet'</span><span class="p">,</span> <span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s1">'Frank'</span>
    <span class="n">assert_equal</span> <span class="s1">'Hello Frank!'</span><span class="p">,</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">body</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_with_user_agent</span>
    <span class="n">get</span> <span class="s1">'/'</span><span class="p">,</span> <span class="p">{},</span> <span class="s1">'HTTP_USER_AGENT'</span> <span class="o">=&gt;</span> <span class="s1">'Songbird'</span>
    <span class="n">assert_equal</span> <span class="s2">"You're using Songbird!"</span><span class="p">,</span> <span class="n">last_response</span><span class="p">.</span><span class="nf">body</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Примечание: если вы используете Sinatra в модульном стиле, замените 
<code class="highlighter-rouge">Sinatra::Application</code> в примере выше на имя класса вашего приложения.</p>

<h2>Sinatra::Base — “прослойки”, библиотеки и модульные приложения</h2>

<p>Описание вашего приложения на верхнем уровне хорошо работает для микроприложений, 
но имеет значительные недостатки при создании многоразовых компонентов, таких как 
Rack “прослойка”, Rails metal, простые библиотеки с серверным компонентом или 
даже расширения Sinatra. Верхний уровень предполагает конфигурацию стиля 
микроприложений (например, одиночный файл приложения, <code class="highlighter-rouge">./public</code> и <code class="highlighter-rouge">./views</code>, 
каталоги, логирование, страницу подробных сведений об исключениях и т.д.). 
И тут на помощь приходит <code class="highlighter-rouge">Sinatra::Base</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">set</span> <span class="ss">:sessions</span><span class="p">,</span> <span class="kp">true</span>
  <span class="n">set</span> <span class="ss">:foo</span><span class="p">,</span> <span class="s1">'bar'</span>

  <span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
    <span class="s1">'Hello world!'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Методы, доступные подклассам <code class="highlighter-rouge">Sinatra::Base</code> идентичны тем, что доступны
приложениям при помощи DSL верхнего уровня. Большинство таких приложений могут быть
конвертированы в <code class="highlighter-rouge">Sinatra::Base</code> компоненты при помощи двух модификаций:</p>

<ul>
  <li>Вы должны подключать <code class="highlighter-rouge">sinatra/base</code> вместо <code class="highlighter-rouge">sinatra</code>, иначе все DSL методы,
предоставляемые Sinatra, будут импортированы в глобальное пространство
имён.</li>
  <li>Поместите все маршруты, обработчики ошибок, фильтры и опции в подкласс
<code class="highlighter-rouge">Sinatra::Base</code>.</li>
</ul>

<p><code class="highlighter-rouge">Sinatra::Base</code> — это чистый лист. Большинство опций, включая встроенный
сервер, по умолчанию отключены. Смотрите 
<a href="http://www.sinatrarb.com/configuration.html">Опции и конфигурация</a> 
для детальной информации об опциях и их поведении. Если вы хотите, чтобы 
поведение было более похоже на то, когда вы определяете своё приложение 
на верхнем уровне (также известно как классический стиль), вы можете 
унаследоваться от <code class="highlighter-rouge">Sinatra::Application</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Application</span>
  <span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
    <span class="s1">'Hello world!'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Модульные приложения против классических</h3>

<p>Вопреки всеобщему убеждению, в классическом стиле (самом простом) нет ничего
плохого. Если этот стиль подходит вашему приложению, вы не обязаны
переписывать его в модульное приложение.</p>

<p>Основным недостатком классического стиля является тот факт, что у вас может
быть только одно приложение Sinatra на один процесс Ruby. Если вы планируете
использовать больше, переключайтесь на модульный стиль. Вы можете смело
смешивать модульный и классический стили.</p>

<p>Переходя с одного стиля на другой, примите во внимание следующие изменения в
настройках:</p>

<table>
  <tr>
    <th>Опция</th>
    <th>Классический</th>
    <th>Модульный</th>
    <th>Модульный</th>
  </tr>

  <tr>
    <td>app_file</td>
    <td>файл с приложением</td>
    <td>файл с подклассом Sinatra::Base</td>
    <td>файл с подклассом Sinatra::Application</td>
  </tr>

  <tr>
    <td>run</td>
    <td>$0 == app_file</td>
    <td>false</td>
    <td>false</td>
  </tr>

  <tr>
    <td>logging</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>method_override</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>inline_templates</td>
    <td>true</td>
    <td>false</td>
    <td>true</td>
  </tr>

  <tr>
    <td>static</td>
    <td>true</td>
    <td>File.exist?(public_folder)</td>
    <td>true</td>
  </tr>
</table>

<h3>Запуск модульных приложений</h3>

<p>Есть два общепринятых способа запускать модульные приложения: запуск напрямую
при помощи <code class="highlighter-rouge">run!</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># my_app.rb</span>
<span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ... здесь код приложения ...</span>

  <span class="c1"># запускаем сервер, если исполняется текущий файл</span>
  <span class="n">run!</span> <span class="k">if</span> <span class="n">app_file</span> <span class="o">==</span> <span class="vg">$0</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Затем:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>ruby my_app.rb
</code></pre>
</div>

<p>Или при помощи конфигурационного файла <code class="highlighter-rouge">config.ru</code>, который позволяет
использовать любой Rack-совместимый сервер приложений:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># config.ru (запускается при помощи Rackup)</span>
<span class="nb">require</span> <span class="s1">'./my_app'</span>
<span class="n">run</span> <span class="no">MyApp</span>
</code></pre>
</div>

<p>Запускаем:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>rackup -p 4567
</code></pre>
</div>

<h3>Запуск классических приложений с config.ru</h3>

<p>Файл приложения:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># app.rb</span>
<span class="nb">require</span> <span class="s1">'sinatra'</span>

<span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
  <span class="s1">'Hello world!'</span>
<span class="k">end</span>
</code></pre>
</div>

<p>И соответствующий <code class="highlighter-rouge">config.ru</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'./app'</span>
<span class="n">run</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Application</span>
</code></pre>
</div>

<h3>Когда использовать config.ru?</h3>

<p>Использование файла <code class="highlighter-rouge">config.ru</code> рекомендовано если:</p>

<ul>
  <li>вы хотите разворачивать своё приложение на различных Rack-совместимых
серверах (Passenger, Unicorn, Heroku, …);</li>
  <li>вы хотите использовать более одного подкласса <code class="highlighter-rouge">Sinatra::Base</code>;</li>
  <li>вы хотите использовать Sinatra только в качестве “прослойки” Rack.</li>
</ul>

<p><strong>Совсем необязательно переходить на использование <code class="highlighter-rouge">config.ru</code> лишь потому,
что вы стали использовать модульный стиль приложения. И необязательно
использовать модульный стиль, чтобы запускать приложение при помощи
<code class="highlighter-rouge">config.ru</code>.</strong></p>

<h3>Использование Sinatra в качестве “прослойки”</h3>

<p>Не только сама Sinatra может использовать “прослойки” Rack, но и любое Sinatra
приложение само может быть добавлено к любому Rack endpoint в качестве
“прослойки”. Этим endpoint (конечной точкой) может быть другое Sinatra
приложение или любое другое приложение, основанное на Rack (Rails/Hamami/Roda/…):</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">LoginScreen</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">enable</span> <span class="ss">:sessions</span>

  <span class="n">get</span><span class="p">(</span><span class="s1">'/login'</span><span class="p">)</span> <span class="p">{</span> <span class="n">haml</span> <span class="ss">:login</span> <span class="p">}</span>

  <span class="n">post</span><span class="p">(</span><span class="s1">'/login'</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'admin'</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">[</span><span class="s1">'password'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'admin'</span>
      <span class="n">session</span><span class="p">[</span><span class="s1">'user_name'</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="n">redirect</span> <span class="s1">'/login'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># "прослойка" будет запущена перед фильтрами</span>
  <span class="n">use</span> <span class="no">LoginScreen</span>

  <span class="n">before</span> <span class="k">do</span>
    <span class="k">unless</span> <span class="n">session</span><span class="p">[</span><span class="s1">'user_name'</span><span class="p">]</span>
      <span class="n">halt</span> <span class="s2">"Access denied, please &lt;a href='/login'&gt;login&lt;/a&gt;."</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"Hello </span><span class="si">#{</span><span class="n">session</span><span class="p">[</span><span class="s1">'user_name'</span><span class="p">]</span><span class="si">}</span><span class="s2">."</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<h3>Создание приложений “на лету”</h3>

<p>Иногда требуется создавать Sinatra приложения “на лету” (например, из другого
приложения), не сохраняя их в константу. Это возможно при помощи <code class="highlighter-rouge">Sinatra.new</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>
<span class="n">my_app</span> <span class="o">=</span> <span class="no">Sinatra</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s2">"hi"</span> <span class="p">}</span> <span class="p">}</span>
<span class="n">my_app</span><span class="p">.</span><span class="nf">run!</span>
</code></pre>
</div>

<p>Этот метод может принимать аргументом приложение, от которого следует
наследоваться:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># config.ru (запускается при помощи Rackup)</span>
<span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="n">controller</span> <span class="o">=</span> <span class="no">Sinatra</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
  <span class="n">enable</span> <span class="ss">:logging</span>
  <span class="n">helpers</span> <span class="no">MyHelpers</span>
<span class="k">end</span>

<span class="n">map</span><span class="p">(</span><span class="s1">'/a'</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">run</span> <span class="no">Sinatra</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span> <span class="p">{</span> <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'a'</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">map</span><span class="p">(</span><span class="s1">'/b'</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">run</span> <span class="no">Sinatra</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">controller</span><span class="p">)</span> <span class="p">{</span> <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="s1">'b'</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
</div>

<p>Это особенно полезно для тестирования расширений Sinatra и при использовании
Sinatra внутри вашей библиотеки.</p>

<p>Это также значительно упрощает использование Sinatra в качестве прослойки:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="n">use</span> <span class="no">Sinatra</span> <span class="k">do</span>
  <span class="n">get</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">run</span> <span class="no">RailsProject</span><span class="o">::</span><span class="no">Application</span>
</code></pre>
</div>

<h2>Области видимости и привязка</h2>

<p>Текущая область видимости определяет методы и переменные, доступные в данный
момент.</p>

<h3>Область видимости приложения / класса</h3>

<p>Любое Sinatra приложение соответствует подклассу <code class="highlighter-rouge">Sinatra::Base</code>. Если вы
используете DSL верхнего уровня (<code class="highlighter-rouge">require 'sinatra'</code>), то этим классом будет
<code class="highlighter-rouge">Sinatra::Application</code>, иначе это будет подкласс, который вы создали вручную.
На уровне класса вам будут доступны такие методы, как <code class="highlighter-rouge">get</code> или <code class="highlighter-rouge">before</code>, но
вы не сможете получить доступ к объектам <code class="highlighter-rouge">request</code> или <code class="highlighter-rouge">session</code>, так как
существует только один класс приложения для всех запросов.</p>

<p>Опции, созданные при помощи <code class="highlighter-rouge">set</code>, являются методами уровня класса:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># Я в области видимости приложения!</span>
  <span class="n">set</span> <span class="ss">:foo</span><span class="p">,</span> <span class="mi">42</span>
  <span class="n">foo</span> <span class="c1"># =&gt; 42</span>

  <span class="n">get</span> <span class="s1">'/foo'</span> <span class="k">do</span>
    <span class="c1"># Я больше не в области видимости приложения!</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>У вас будет привязка к области видимости приложения внутри:</p>

<ul>
  <li>тела вашего класса приложения;</li>
  <li>методов, определённых расширениями;</li>
  <li>блока, переданного в <code class="highlighter-rouge">helpers</code>;</li>
  <li>блоков, использованных как значения для <code class="highlighter-rouge">set</code>;</li>
  <li>блока, переданного в <code class="highlighter-rouge">Sinatra.new</code>.</li>
</ul>

<p>Вы можете получить доступ к объекту области видимости (классу приложения)
следующими способами:</p>

<ul>
  <li>через объект, переданный блокам конфигурации (<code class="highlighter-rouge">configure { |c| ... }</code>);</li>
  <li>
<code class="highlighter-rouge">settings</code> внутри области видимости запроса.</li>
</ul>

<h3>Область видимости запроса / экземпляра</h3>

<p>Для каждого входящего запроса будет создан новый экземпляр вашего приложения,
и все блоки обработчика будут запущены в этом контексте. В этой области
видимости вам доступны <code class="highlighter-rouge">request</code> и <code class="highlighter-rouge">session</code> объекты, а также вызовы методов
рендеринга, такие как <code class="highlighter-rouge">erb</code> или <code class="highlighter-rouge">haml</code>. Вы можете получить доступ к области
видимости приложения из контекста запроса используя метод-помощник
<code class="highlighter-rouge">settings</code>:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="k">class</span> <span class="nc">MyApp</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># Я в области видимости приложения!</span>
  <span class="n">get</span> <span class="s1">'/define_route/:name'</span> <span class="k">do</span>
    <span class="c1"># Область видимости запроса '/define_route/:name'</span>
    <span class="vi">@value</span> <span class="o">=</span> <span class="mi">42</span>

    <span class="n">settings</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"/</span><span class="si">#{</span><span class="n">params</span><span class="p">[</span><span class="s1">'name'</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span> <span class="k">do</span>
      <span class="c1"># Область видимости запроса "/#{params['name']}"</span>
      <span class="vi">@value</span> <span class="c1"># =&gt; nil (другой запрос)</span>
    <span class="k">end</span>

    <span class="s2">"Route defined!"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
</div>

<p>У вас будет привязка к области видимости запроса в:</p>

<ul>
  <li>get, head, post, put, delete, options, patch, link и unlink блоках;</li>
  <li>before и after фильтрах;</li>
  <li>методах-помощниках;</li>
  <li>шаблонах/отображениях.</li>
</ul>

<h3>Область видимости делегирования</h3>

<p>Область видимости делегирования просто перенаправляет методы в область
видимости класса. Однако, она не полностью ведет себя как область видимости
класса, так как у вас нет привязки к классу. Только методы, явно помеченные
для делегирования, будут доступны, а переменных/состояний области видимости
класса не будет (иначе говоря, у вас будет другой <code class="highlighter-rouge">self</code> объект). Вы можете
непосредственно добавить методы делегирования, используя
<code class="highlighter-rouge">Sinatra::Delegator.delegate :method_name</code>.</p>

<p>У вас будет контекст делегирования внутри:</p>

<ul>
  <li>привязки верхнего уровня, если вы сделали <code class="highlighter-rouge">require "sinatra"</code>;</li>
  <li>объекта, расширенного при помощи <code class="highlighter-rouge">Sinatra::Delegator</code>.</li>
</ul>

<p>Посмотрите сами в код: вот
<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/base.rb#L1609-1633">примесь Sinatra::Delegator</a>
<a href="https://github.com/sinatra/sinatra/blob/ca06364/lib/sinatra/main.rb#L28-30">расширяет главный объект</a>.</p>

<h2>Командная строка</h2>

<p>Sinatra приложения могут быть запущены напрямую:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>ruby myapp.rb <span class="o">[</span>-h] <span class="o">[</span>-x] <span class="o">[</span>-q] <span class="o">[</span>-e ENVIRONMENT] <span class="o">[</span>-p PORT] <span class="o">[</span>-o HOST] <span class="o">[</span>-s HANDLER]
</code></pre>
</div>

<p>Поддерживаемые опции:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>-h # раздел помощи
-p # указание порта (по умолчанию 4567)
-o # указание хоста (по умолчанию 0.0.0.0)
-e # указание окружения, режима (по умолчанию development)
-s # указание rack сервера/обработчика (по умолчанию thin)
-q # включить тихий режим для сервера (по умолчанию выключен)
-x # включить мьютекс-блокировку (по умолчанию выключена)
</code></pre>
</div>

<h3>Многопоточность</h3>

<p><em>Данный раздел является перефразированным <a href="https://stackoverflow.com/a/6282999/5245129">ответом пользователя Konstantin</a> на StackOverflow</em></p>

<p>Sinatra не навязывает каких-либо моделей параллелизма, но для этих целей можно
использовать любой Rack обработчик (сервер), например Thin, Puma или WEBrick. Сама
по себе Sinatra потокобезопасна, поэтому нет никаких проблем в использовании
поточной модели параллелизма в Rack обработчике. Это означает, что когда
запускается сервер, вы должны указать правильный метод вызова для конкретного
Rack обработчика. Пример ниже показывает, как можно запустить мультипоточный
Thin сервер:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="c1"># app.rb</span>

<span class="nb">require</span> <span class="s1">'sinatra/base'</span>

<span class="k">class</span> <span class="nc">App</span> <span class="o">&lt;</span> <span class="no">Sinatra</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">get</span> <span class="s1">'/'</span> <span class="k">do</span>
    <span class="s2">"Hello, World"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">App</span><span class="p">.</span><span class="nf">run!</span>

</code></pre>
</div>

<p>Для запуска сервере выполните следующую команду:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>thin --threaded start
</code></pre>
</div>

<h2>Системные требования</h2>

<p>Следующие версии Ruby официально поддерживаются:</p>
<dl>
  <dt>Ruby 2.3</dt>
  <dd>
    Версия 2.3 полностью поддерживается и рекомендуется. В настоящее время нет 
  планов отказаться от официальной поддержки.
  </dd>

  <dt>Rubinius</dt>
  <dd>
    Rubinius официально поддерживается (Rubinius &gt;= 2.x). Рекомендуется
    выполнить <tt>gem install puma</tt>.
  </dd>

  <dt>JRuby</dt>
  <dd>
    Официально поддерживается последний стабильный релиз JRuby. Не 
    рекомендуется использовать расширений на C в JRuby. Рекомендуется
    выполнить <tt>gem install trinidad</tt>.
  </dd>
</dl>

<p>Версии Ruby ниже 2.2.2 более не поддерживаются в Sinatra 2.0.</p>

<p>Мы также следим за предстоящими к выходу версиями Ruby.</p>

<p>Следующие реализации Ruby не поддерживаются официально, однако известно, что
на них запускается Sinatra:</p>

<ul>
  <li>старые версии JRuby и Rubinius;</li>
  <li>Ruby Enterprise Edition;</li>
  <li>MacRuby, Maglev, IronRuby;</li>
  <li>Ruby 1.9.0 и 1.9.1 (настоятельно не рекомендуются к использованию).</li>
</ul>

<p>То, что версия официально не поддерживается, означает, что, если что-то не
работает на этой версии, а на поддерживаемой работает — это не наша проблема,
а их.</p>

<p>Мы также запускаем наши CI-тесты на ruby-head (будущие версии MRI), но мы не 
можем ничего гарантировать, так как ведётся постоянная разработка. 
Предполагается, что предстоящие релизы 2.x будут полностью поддерживаться.</p>

<p>Sinatra должна работать на любой операционной системе, в которой есть одна из
указанных выше версий Ruby.</p>

<p>Если вы запускаете MacRuby, вы должны выполнить <code class="highlighter-rouge">gem install control_tower</code>.</p>

<p>Пока невозможно запустить Sinatra на Cardinal, SmallRuby, BlueRuby и на любой
версии Ruby ниже 2.2.</p>

<h2>Самая свежая версия</h2>

<p>Если вы хотите использовать самый последний релиз Sinatra, не бойтесь запускать
своё приложение вместе с кодом из master ветки Sinatra, так как она весьма стабильна.</p>

<p>Мы также время от времени выпускаем предварительные версии, которые вы можете
установить следующим образом:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>gem install sinatra --pre
</code></pre>
</div>

<p>таким образом вы сможете воспользоваться некоторыми самыми последними возможностями.</p>

<h3>При помощи Bundler</h3>

<p>Если вы хотите запускать своё приложение с последней версией Sinatra, то
рекомендуем использовать <a href="http://bundler.io">Bundler</a>.</p>

<p>Для начала установите Bundler, если у вас его ещё нет:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>gem install bundler
</code></pre>
</div>

<p>Затем создайте файл <code class="highlighter-rouge">Gemfile</code> в директории вашего проекта:</p>

<div class="language-ruby highlighter-rouge">
<pre class="highlight"><code><span class="n">source</span> <span class="s1">'https://rubygems.org'</span>
<span class="n">gem</span> <span class="s1">'sinatra'</span><span class="p">,</span> <span class="ss">:github</span> <span class="o">=&gt;</span> <span class="s1">'sinatra/sinatra'</span>

<span class="c1"># другие зависимости</span>
<span class="n">gem</span> <span class="s1">'haml'</span>                    <span class="c1"># в том случае, если используете haml</span>
</code></pre>
</div>

<p>Имейте ввиду, что вам необходимо будет указывать все зависимости вашего приложения
в <code class="highlighter-rouge">Gemfile</code>. Необходимые зависимости самой библиотеки Sinatra (Rack и Tilt)
будут автоматически скачаны и добавлены Bundler.</p>

<p>Теперь вы можете запускать своё приложение следующим образом:</p>

<div class="language-shell highlighter-rouge">
<pre class="highlight"><code>bundle <span class="nb">exec </span>ruby myapp.rb
</code></pre>
</div>

<h2>Версии</h2>

<p>Sinatra использует <a href="https://semver.org/">Semantic Versioning</a>: как SemVer, так и
SemVerTag.</p>

<h2>Дальнейшее чтение</h2>

<ul>
  <li>
<a href="http://www.sinatrarb.com/">Веб-сайт проекта</a> — Дополнительная
документация, новости и ссылки на другие ресурсы.</li>
  <li>
<a href="http://www.sinatrarb.com/contributing">Участие в проекте</a> — Обнаружили
баг? Нужна помощь? Написали патч?</li>
  <li><a href="https://github.com/sinatra/sinatra/issues">Отслеживание проблем/ошибок</a></li>
  <li><a href="https://twitter.com/sinatra">Twitter</a></li>
  <li><a href="https://groups.google.com/forum/#!forum/sinatrarb">Группы рассылки</a></li>
  <li>IRC: <a href="irc://chat.freenode.net/#sinatra">#sinatra</a> на <a href="https://freenode.net">Freenode</a>
</li>
  <li>
<a href="https://sinatrarb.slack.com">Sinatra и Друзья</a> на Slack, а так же
<a href="https://sinatra-slack.herokuapp.com/">ссылка для инвайта</a>.</li>
  <li>
<a href="https://github.com/sinatra/sinatra-book">Sinatra Book</a> учебник и сборник рецептов</li>
  <li>
<a href="http://recipes.sinatrarb.com/">Sinatra Recipes</a> сборник рецептов</li>
  <li>API документация к <a href="http://www.rubydoc.info/gems/sinatra">последнему релизу</a>
или <a href="http://www.rubydoc.info/github/sinatra/sinatra">текущему HEAD</a> на
http://www.rubydoc.info/</li>
  <li><a href="https://travis-ci.org/sinatra/sinatra">Сервер непрерывной интеграции</a></li>
</ul>
</body></html>
